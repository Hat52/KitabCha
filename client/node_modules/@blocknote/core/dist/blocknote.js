var Et = Object.defineProperty;
var Ct = (o, t, e) => t in o ? Et(o, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : o[t] = e;
var u = (o, t, e) => (Ct(o, typeof t != "symbol" ? t + "" : t, e), e);
import { Extension as E, findChildren as G, combineTransactionSteps as Mt, getChangedRanges as Bt, findChildrenInRange as Tt, Mark as rt, Node as S, mergeAttributes as w, InputRule as j, findParentNode as wt, isTextSelection as St, isNodeSelection as xt, posToDOMRect as nt, getMarkRange as X, extensions as N, Editor as It } from "@tiptap/core";
import { Slice as P, Fragment as L, DOMSerializer as Pt, DOMParser as Lt } from "prosemirror-model";
import { Plugin as C, PluginKey as v, TextSelection as Q, Selection as $, NodeSelection as _t } from "prosemirror-state";
import { v4 as At } from "uuid";
import it from "rehype-parse";
import Nt from "rehype-remark";
import st from "rehype-stringify";
import at from "remark-gfm";
import Ht from "remark-parse";
import Ot from "remark-rehype";
import Dt from "remark-stringify";
import { unified as W } from "unified";
import { fromDom as Z } from "hast-util-from-dom";
import { Bold as Ft } from "@tiptap/extension-bold";
import { Code as Rt } from "@tiptap/extension-code";
import zt from "@tiptap/extension-collaboration";
import Ut from "@tiptap/extension-collaboration-cursor";
import { Dropcursor as $t } from "@tiptap/extension-dropcursor";
import { Gapcursor as Gt } from "@tiptap/extension-gapcursor";
import { HardBreak as qt } from "@tiptap/extension-hard-break";
import { History as jt } from "@tiptap/extension-history";
import { Italic as Wt } from "@tiptap/extension-italic";
import { Link as lt } from "@tiptap/extension-link";
import { Strike as Yt } from "@tiptap/extension-strike";
import { Text as Kt } from "@tiptap/extension-text";
import { Underline as Vt } from "@tiptap/extension-underline";
import * as Jt from "prosemirror-view";
import { Decoration as D, DecorationSet as F } from "prosemirror-view";
const O = [
  "backgroundColor",
  "textColor",
  "textAlignment"
], tt = {
  paragraph: /* @__PURE__ */ new Set([...O]),
  heading: /* @__PURE__ */ new Set([
    ...O,
    "level"
  ]),
  numberedListItem: /* @__PURE__ */ new Set([
    ...O
  ]),
  bulletListItem: /* @__PURE__ */ new Set([...O])
};
function g(o, t) {
  if (t < 0 || t > o.nodeSize)
    return;
  const e = o.resolve(t), r = e.depth;
  let n = e.node(r), i = r;
  for (; ; ) {
    if (i < 0)
      return;
    if (n.type.name === "blockContainer")
      break;
    i -= 1, n = e.node(i);
  }
  const a = n.attrs.id, s = n.firstChild, l = s.type, d = n.childCount === 2 ? n.lastChild.childCount : 0, c = e.start(i), h = e.end(i);
  return {
    id: a,
    node: n,
    contentNode: s,
    contentType: l,
    numChildBlocks: d,
    startPos: c,
    endPos: h,
    depth: i
  };
}
function Xt(o, t = JSON.stringify) {
  const e = {};
  return o.filter((r) => {
    const n = t(r);
    return Object.prototype.hasOwnProperty.call(e, n) ? !1 : e[n] = !0;
  });
}
function Qt(o) {
  const t = o.filter(
    (r, n) => o.indexOf(r) !== n
  );
  return Xt(t);
}
const Y = E.create({
  name: "uniqueID",
  // we’ll set a very high priority to make sure this runs first
  // and is compatible with `appendTransaction` hooks of other extensions
  priority: 1e4,
  addOptions() {
    return {
      attributeName: "id",
      types: [],
      generateID: () => window.__TEST_OPTIONS ? (window.__TEST_OPTIONS.mockID === void 0 ? window.__TEST_OPTIONS.mockID = 0 : window.__TEST_OPTIONS.mockID++, window.__TEST_OPTIONS.mockID.toString()) : At(),
      filterTransaction: null
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          [this.options.attributeName]: {
            default: null,
            parseHTML: (o) => o.getAttribute(`data-${this.options.attributeName}`),
            renderHTML: (o) => ({
              [`data-${this.options.attributeName}`]: o[this.options.attributeName]
            })
          }
        }
      }
    ];
  },
  // check initial content for missing ids
  onCreate() {
    if (this.editor.extensionManager.extensions.find(
      (l) => l.name === "collaboration"
    ))
      return;
    const { view: o, state: t } = this.editor, { tr: e, doc: r } = t, { types: n, attributeName: i, generateID: a } = this.options;
    G(r, (l) => n.includes(l.type.name) && l.attrs[i] === null).forEach(({ node: l, pos: d }) => {
      e.setNodeMarkup(d, void 0, {
        ...l.attrs,
        [i]: a()
      });
    }), e.setMeta("addToHistory", !1), o.dispatch(e);
  },
  addProseMirrorPlugins() {
    let o = null, t = !1;
    return [
      new C({
        key: new v("uniqueID"),
        appendTransaction: (e, r, n) => {
          const i = e.some((m) => m.docChanged) && !r.doc.eq(n.doc), a = this.options.filterTransaction && e.some((m) => {
            var y, k;
            return !(!((k = (y = this.options).filterTransaction) === null || k === void 0) && k.call(y, m));
          });
          if (!i || a)
            return;
          const { tr: s } = n, { types: l, attributeName: d, generateID: c } = this.options, h = Mt(
            r.doc,
            e
          ), { mapping: f } = h;
          if (Bt(h).forEach(({ newRange: m }) => {
            const y = Tt(
              n.doc,
              m,
              (M) => l.includes(M.type.name)
            ), k = y.map(({ node: M }) => M.attrs[d]).filter((M) => M !== null), z = Qt(k);
            y.forEach(({ node: M, pos: H }) => {
              var U;
              const J = (U = s.doc.nodeAt(H)) === null || U === void 0 ? void 0 : U.attrs[d];
              if (J === null) {
                s.setNodeMarkup(H, void 0, {
                  ...M.attrs,
                  [d]: c()
                });
                return;
              }
              const { deleted: vt } = f.invert().mapResult(H);
              vt && z.includes(J) && s.setNodeMarkup(H, void 0, {
                ...M.attrs,
                [d]: c()
              });
            });
          }), !!s.steps.length)
            return s;
        },
        // we register a global drag handler to track the current drag source element
        view(e) {
          const r = (n) => {
            var i;
            o = !((i = e.dom.parentElement) === null || i === void 0) && i.contains(n.target) ? e.dom.parentElement : null;
          };
          return window.addEventListener("dragstart", r), {
            destroy() {
              window.removeEventListener("dragstart", r);
            }
          };
        },
        props: {
          // `handleDOMEvents` is called before `transformPasted`
          // so we can do some checks before
          handleDOMEvents: {
            // only create new ids for dropped content while holding `alt`
            // or content is dragged from another editor
            drop: (e, r) => {
              var n;
              return (o !== e.dom.parentElement || ((n = r.dataTransfer) === null || n === void 0 ? void 0 : n.effectAllowed) === "copy") && (o = null, t = !0), !1;
            },
            // always create new ids on pasted content
            paste: () => (t = !0, !1)
          },
          // we’ll remove ids for every pasted node
          // so we can create a new one within `appendTransaction`
          transformPasted: (e) => {
            if (!t)
              return e;
            const { types: r, attributeName: n } = this.options, i = (a) => {
              const s = [];
              return a.forEach((l) => {
                if (l.isText) {
                  s.push(l);
                  return;
                }
                if (!r.includes(l.type.name)) {
                  s.push(l.copy(i(l.content)));
                  return;
                }
                const d = l.type.create(
                  {
                    ...l.attrs,
                    [n]: null
                  },
                  i(l.content),
                  l.marks
                );
                s.push(d);
              }), L.from(s);
            };
            return t = !1, new P(
              i(e.content),
              e.openStart,
              e.openEnd
            );
          }
        }
      })
    ];
  }
});
class Zt extends Error {
  constructor(t) {
    super(`Unreachable case: ${t}`);
  }
}
const dt = /* @__PURE__ */ new Set([
  "bold",
  "italic",
  "underline",
  "strike",
  "code"
]), ct = /* @__PURE__ */ new Set(["textColor", "backgroundColor"]);
function te(o, t) {
  const e = [];
  for (const [r, n] of Object.entries(o.styles))
    dt.has(r) ? e.push(t.mark(r)) : ct.has(r) && e.push(t.mark(r, { color: n }));
  return t.text(o.text, e);
}
function ee(o, t) {
  const e = t.marks.link.create({
    href: o.href
  });
  return ut(o.content, t).map((r) => r.mark([...r.marks, e]));
}
function ut(o, t) {
  let e = [];
  if (typeof o == "string")
    return e.push(t.text(o)), e;
  for (const r of o)
    e.push(te(r, t));
  return e;
}
function ht(o, t) {
  let e = [];
  for (const r of o)
    if (r.type === "link")
      e.push(...ee(r, t));
    else if (r.type === "text")
      e.push(...ut([r], t));
    else
      throw new Zt(r);
  return e;
}
function R(o, t) {
  let e = o.id;
  e === void 0 && (e = Y.options.generateID());
  let r = o.type;
  r === void 0 && (r = "paragraph");
  let n;
  if (!o.content)
    n = t.nodes[r].create(o.props);
  else if (typeof o.content == "string")
    n = t.nodes[r].create(
      o.props,
      t.text(o.content)
    );
  else {
    const s = ht(o.content, t);
    n = t.nodes[r].create(o.props, s);
  }
  const i = [];
  if (o.children)
    for (const s of o.children)
      i.push(R(s, t));
  const a = t.nodes.blockGroup.create({}, i);
  return t.nodes.blockContainer.create(
    {
      id: e,
      ...o.props
    },
    i.length > 0 ? [n, a] : n
  );
}
function oe(o) {
  const t = [];
  let e;
  return o.content.forEach((r) => {
    const n = {};
    let i;
    for (const a of r.marks)
      if (a.type.name === "link")
        i = a;
      else if (dt.has(a.type.name))
        n[a.type.name] = !0;
      else if (ct.has(a.type.name))
        n[a.type.name] = a.attrs.color;
      else
        throw Error("Mark is of an unrecognized type: " + a.type.name);
    i && e && i.attrs.href === e.href ? e.content.push({
      type: "text",
      text: r.textContent,
      styles: n
    }) : i ? (e = {
      type: "link",
      href: i.attrs.href,
      content: [
        {
          type: "text",
          text: r.textContent,
          styles: n
        }
      ]
    }, t.push(e)) : (t.push({
      type: "text",
      text: r.textContent,
      styles: n
    }), e = void 0);
  }), t;
}
function B(o, t) {
  if (o.type.name !== "blockContainer")
    throw Error(
      "Node must be of type blockContainer, but is of type" + o.type.name + "."
    );
  const e = t == null ? void 0 : t.get(o);
  if (e)
    return e;
  const r = g(o, 0);
  let n = r.id;
  n === null && (n = Y.options.generateID());
  const i = {};
  for (const [d, c] of Object.entries({
    ...r.node.attrs,
    ...r.contentNode.attrs
  })) {
    if (!(r.contentType.name in tt))
      throw Error(
        "Block is of an unrecognized type: " + r.contentType.name
      );
    tt[r.contentType.name].has(d) && (i[d] = c);
  }
  const a = oe(r.contentNode), s = [];
  for (let d = 0; d < r.numChildBlocks; d++)
    s.push(B(r.node.lastChild.child(d)));
  const l = {
    id: n,
    type: r.contentType.name,
    props: i,
    content: a,
    children: s
  };
  return t == null || t.set(o, l), l;
}
function K(o, t) {
  let e, r;
  if (t.firstChild.descendants((n, i) => e ? !1 : n.type.name !== "blockContainer" || n.attrs.id !== o ? !0 : (e = n, r = i + 1, !1)), e === void 0 || r === void 0)
    throw Error("Could not find block in the editor with matching ID.");
  return {
    node: e,
    posBeforeNode: r
  };
}
function pt(o, t, e = "before", r) {
  const n = typeof t == "string" ? t : t.id, i = [];
  for (const d of o)
    i.push(R(d, r.schema));
  let a = -1;
  const { node: s, posBeforeNode: l } = K(n, r.state.doc);
  if (e === "before" && (a = l), e === "after" && (a = l + s.nodeSize), e === "nested") {
    if (s.childCount < 2) {
      a = l + s.firstChild.nodeSize + 1;
      const d = r.state.schema.nodes.blockGroup.create(
        {},
        i
      );
      r.view.dispatch(
        r.state.tr.insert(a, d)
      );
      return;
    }
    a = l + s.firstChild.nodeSize + 2;
  }
  r.view.dispatch(r.state.tr.insert(a, i));
}
function re(o, t, e) {
  const r = typeof o == "string" ? o : o.id, { posBeforeNode: n } = K(r, e.state.doc);
  e.commands.BNUpdateBlock(n + 1, t);
}
function ft(o, t) {
  const e = new Set(
    o.map(
      (n) => typeof n == "string" ? n : n.id
    )
  );
  let r = 0;
  if (t.state.doc.descendants((n, i) => {
    if (e.size === 0)
      return !1;
    if (n.type.name !== "blockContainer" || !e.has(n.attrs.id))
      return !0;
    e.delete(n.attrs.id);
    const a = t.state.doc.nodeSize;
    t.commands.BNDeleteBlock(i - r + 1);
    const s = t.state.doc.nodeSize;
    return r += a - s, !1;
  }), e.size > 0) {
    let n = [...e].join(`
`);
    throw Error(
      "Blocks with the following IDs could not be found in the editor: " + n
    );
  }
}
function ne(o, t, e) {
  pt(t, o[0], "before", e), ft(o, e);
}
function ie() {
  const o = (t) => {
    let e = t.children.length;
    for (let r = 0; r < e; r++) {
      const n = t.children[r];
      if (n.type === "element" && (o(n), n.tagName === "u"))
        if (n.children.length > 0) {
          t.children.splice(r, 1, ...n.children);
          const i = n.children.length - 1;
          e += i, r += i;
        } else
          t.children.splice(r, 1), e--, r--;
    }
  };
  return o;
}
function se(o) {
  const t = /* @__PURE__ */ new Set([
    ...o.orderedListItemBlockTypes,
    ...o.unorderedListItemBlockTypes
  ]), e = (r) => {
    let n = r.children.length, i;
    for (let a = 0; a < n; a++) {
      const l = r.children[a].children[0], d = l.children[0], c = l.children.length === 2 ? l.children[1] : null, h = t.has(
        d.properties.dataContentType
      ), f = h ? o.orderedListItemBlockTypes.has(
        d.properties.dataContentType
      ) ? "ol" : "ul" : null;
      if (c !== null && e(c), i && i.tagName !== f) {
        r.children.splice(
          a - i.children.length,
          i.children.length,
          i
        );
        const p = i.children.length - 1;
        a -= p, n -= p, i = void 0;
      }
      if (h) {
        i || (i = Z(
          document.createElement(f)
        ));
        const p = Z(
          document.createElement("li")
        );
        p.children.push(d.children[0]), c !== null && p.children.push(...c.children), i.children.push(p);
      } else if (c !== null) {
        r.children.splice(a + 1, 0, ...c.children), r.children[a] = d.children[0];
        const p = c.children.length;
        a += p, n += p;
      } else
        r.children[a] = d.children[0];
    }
    i && r.children.splice(
      n - i.children.length,
      i.children.length,
      i
    );
  };
  return e;
}
async function mt(o, t) {
  const e = document.createElement("div"), r = Pt.fromSchema(t);
  for (const i of o) {
    const a = R(i, t), s = r.serializeNode(a);
    e.appendChild(s);
  }
  return (await W().use(it, { fragment: !0 }).use(se, {
    orderedListItemBlockTypes: /* @__PURE__ */ new Set(["numberedListItem"]),
    unorderedListItemBlockTypes: /* @__PURE__ */ new Set(["bulletListItem"])
  }).use(st).process(e.innerHTML)).value;
}
async function gt(o, t) {
  const e = document.createElement("div");
  e.innerHTML = o.trim();
  const n = Lt.fromSchema(t).parse(e), i = [];
  for (let a = 0; a < n.firstChild.childCount; a++)
    i.push(B(n.firstChild.child(a)));
  return i;
}
async function ae(o, t) {
  return (await W().use(it, { fragment: !0 }).use(ie).use(Nt).use(at).use(Dt).process(await mt(o, t))).value;
}
async function le(o, t) {
  const e = await W().use(Ht).use(at).use(Ot).use(st).process(o);
  return gt(e.value, t);
}
const de = "_bnEditor_ywyu7_3", ce = "_bnRoot_ywyu7_20", ue = "_defaultStyles_ywyu7_35", he = "_dragPreview_ywyu7_69", _ = {
  bnEditor: de,
  bnRoot: ce,
  defaultStyles: ue,
  dragPreview: he,
  "collaboration-cursor__caret": "_collaboration-cursor__caret_ywyu7_75",
  "collaboration-cursor__label": "_collaboration-cursor__label_ywyu7_86"
}, pe = E.create({
  name: "blockBackgroundColor",
  addGlobalAttributes() {
    return [
      {
        types: ["blockContainer"],
        attributes: {
          backgroundColor: {
            default: "default",
            parseHTML: (o) => o.hasAttribute("data-background-color") ? o.getAttribute("data-background-color") : "default",
            renderHTML: (o) => o.backgroundColor !== "default" && {
              "data-background-color": o.backgroundColor
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setBlockBackgroundColor: (o, t) => ({ state: e, view: r }) => {
        const n = g(e.doc, o);
        return n === void 0 ? !1 : (e.tr.setNodeAttribute(
          n.startPos - 1,
          "backgroundColor",
          t
        ), r.focus(), !0);
      }
    };
  }
}), fe = rt.create({
  name: "backgroundColor",
  addAttributes() {
    return {
      color: {
        default: void 0,
        parseHTML: (o) => o.getAttribute("data-background-color"),
        renderHTML: (o) => ({
          "data-background-color": o.color
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (o) => typeof o == "string" ? !1 : o.hasAttribute("data-background-color") ? { color: o.getAttribute("data-background-color") } : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: o }) {
    return ["span", o, 0];
  },
  addCommands() {
    return {
      setBackgroundColor: (o) => ({ commands: t }) => o !== "default" ? t.setMark(this.name, { color: o }) : t.unsetMark(this.name)
    };
  }
}), et = new v("previous-blocks"), me = {
  // Numbered List Items
  index: "index",
  // Headings
  level: "level",
  // All Blocks
  type: "type",
  depth: "depth",
  "depth-change": "depth-change"
}, ge = () => {
  let o;
  return new C({
    key: et,
    view(t) {
      return {
        update: async (e, r) => {
          var n;
          ((n = this.key) == null ? void 0 : n.getState(e.state).updatedBlocks.size) > 0 && (o = setTimeout(() => {
            e.dispatch(
              e.state.tr.setMeta(et, { clearUpdate: !0 })
            );
          }, 0));
        },
        destroy: () => {
          o && clearTimeout(o);
        }
      };
    },
    state: {
      init() {
        return {
          // Block attributes, by block ID, from just before the previous transaction.
          prevTransactionOldBlockAttrs: {},
          // Block attributes, by block ID, from just before the current transaction.
          currentTransactionOldBlockAttrs: {},
          // Set of IDs of blocks whose attributes changed from the current transaction.
          updatedBlocks: /* @__PURE__ */ new Set()
        };
      },
      apply(t, e, r, n) {
        if (e.currentTransactionOldBlockAttrs = {}, e.updatedBlocks.clear(), !t.docChanged || r.doc.eq(n.doc))
          return e;
        const i = {}, a = G(r.doc, (d) => d.attrs.id), s = new Map(
          a.map((d) => [d.node.attrs.id, d])
        ), l = G(n.doc, (d) => d.attrs.id);
        for (let d of l) {
          const c = s.get(d.node.attrs.id), h = c == null ? void 0 : c.node.firstChild, f = d.node.firstChild;
          if (c && h && f) {
            const p = {
              index: f.attrs.index,
              level: f.attrs.level,
              type: f.type.name,
              depth: n.doc.resolve(d.pos).depth
            };
            let m = {
              index: h.attrs.index,
              level: h.attrs.level,
              type: h.type.name,
              depth: r.doc.resolve(c.pos).depth
            };
            i[d.node.attrs.id] = m, t.getMeta("numberedListIndexing") && (d.node.attrs.id in e.prevTransactionOldBlockAttrs && (m = e.prevTransactionOldBlockAttrs[d.node.attrs.id]), p.type === "numberedListItem" && (m.index = p.index)), e.currentTransactionOldBlockAttrs[d.node.attrs.id] = m, JSON.stringify(m) !== JSON.stringify(p) && (m["depth-change"] = m.depth - p.depth, e.updatedBlocks.add(d.node.attrs.id));
          }
        }
        return e.prevTransactionOldBlockAttrs = i, e;
      }
    },
    props: {
      decorations(t) {
        const e = this.getState(t);
        if (e.updatedBlocks.size === 0)
          return;
        const r = [];
        return t.doc.descendants((n, i) => {
          if (!n.attrs.id || !e.updatedBlocks.has(n.attrs.id))
            return;
          const a = e.currentTransactionOldBlockAttrs[n.attrs.id], s = {};
          for (let [d, c] of Object.entries(a))
            s["data-prev-" + me[d]] = c || "none";
          const l = D.node(i, i + n.nodeSize, {
            ...s
          });
          r.push(l);
        }), F.create(t.doc, r);
      }
    }
  });
}, ke = "_blockOuter_1qj38_5", ye = "_blockContent_1qj38_10", be = "_blockGroup_1qj38_30", ve = "_block_1qj38_5", Ee = "_isEmpty_1qj38_228", Ce = "_isFilter_1qj38_229", Me = "_hasAnchor_1qj38_251", b = {
  blockOuter: ke,
  blockContent: ye,
  blockGroup: be,
  block: ve,
  isEmpty: Ee,
  isFilter: Ce,
  hasAnchor: Me
}, Be = {
  blockColor: "data-block-color",
  blockStyle: "data-block-style",
  id: "data-id",
  depth: "data-depth",
  depthChange: "data-depth-change"
}, Te = S.create({
  name: "blockContainer",
  group: "blockContainer",
  // A block always contains content, and optionally a blockGroup which contains nested blocks
  content: "blockContent blockGroup?",
  // Ensures content-specific keyboard handlers trigger first.
  priority: 50,
  defining: !0,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "div",
        getAttrs: (o) => {
          if (typeof o == "string")
            return !1;
          const t = {};
          for (let [e, r] of Object.entries(Be))
            o.getAttribute(r) && (t[e] = o.getAttribute(r));
          return o.getAttribute("data-node-type") === "blockContainer" ? t : !1;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: o }) {
    return [
      "div",
      w(o, {
        class: b.blockOuter,
        "data-node-type": "block-outer"
      }),
      [
        "div",
        w(o, {
          // TODO: maybe remove html attributes from inner block
          class: b.block,
          "data-node-type": this.name
        }),
        0
      ]
    ];
  },
  addCommands() {
    return {
      // Creates a new text block at a given position.
      BNCreateBlock: (o) => ({ state: t, dispatch: e }) => {
        const r = t.schema.nodes.blockContainer.createAndFill();
        return e && t.tr.insert(o, r), !0;
      },
      // Deletes a block at a given position.
      BNDeleteBlock: (o) => ({ state: t, dispatch: e }) => {
        const r = g(t.doc, o);
        if (r === void 0)
          return !1;
        const { startPos: n, endPos: i } = r;
        return e && t.tr.deleteRange(n, i), !0;
      },
      // Updates a block at a given position.
      BNUpdateBlock: (o, t) => ({ state: e, dispatch: r }) => {
        const n = g(e.doc, o);
        if (n === void 0)
          return !1;
        const { startPos: i, endPos: a, node: s, contentNode: l } = n;
        if (r) {
          if (t.children !== void 0) {
            const d = [];
            for (const c of t.children)
              d.push(R(c, e.schema));
            s.childCount === 2 ? e.tr.replace(
              i + l.nodeSize + 1,
              a - 1,
              new P(L.from(d), 0, 0)
            ) : e.tr.insert(
              i + l.nodeSize,
              e.schema.nodes.blockGroup.create({}, d)
            );
          }
          if (t.content !== void 0) {
            let d = [];
            typeof t.content == "string" ? d.push(e.schema.text(t.content)) : d = ht(t.content, e.schema), e.tr.replace(
              i + 1,
              i + l.nodeSize - 1,
              new P(L.from(d), 0, 0)
            );
          }
          e.tr.setNodeMarkup(
            i,
            t.type === void 0 ? void 0 : e.schema.nodes[t.type],
            {
              ...l.attrs,
              ...t.props
            }
          ), e.tr.setNodeMarkup(i - 1, void 0, {
            ...s.attrs,
            ...t.props
          });
        }
        return !0;
      },
      // Appends the text contents of a block to the nearest previous block, given a position between them. Children of
      // the merged block are moved out of it first, rather than also being merged.
      //
      // In the example below, the position passed into the function is between Block1 and Block2.
      //
      // Block1
      //    Block2
      // Block3
      //    Block4
      //        Block5
      //
      // Becomes:
      //
      // Block1
      //    Block2Block3
      // Block4
      //     Block5
      BNMergeBlocks: (o) => ({ state: t, dispatch: e }) => {
        const r = t.doc.resolve(o + 1).node().type.name === "blockContainer", n = t.doc.resolve(o - 1).node().type.name === "blockContainer";
        if (!r || !n)
          return !1;
        const i = g(
          t.doc,
          o + 1
        ), { node: a, contentNode: s, startPos: l, endPos: d, depth: c } = i;
        if (a.childCount === 2) {
          const p = t.doc.resolve(
            l + s.nodeSize + 1
          ), m = t.doc.resolve(d - 1), y = p.blockRange(m);
          e && t.tr.lift(y, c - 1);
        }
        let h = o - 1, f = g(t.doc, h);
        for (; f.numChildBlocks > 0; )
          if (h--, f = g(t.doc, h), f === void 0)
            return !1;
        return e && (t.tr.deleteRange(l, l + s.nodeSize), t.tr.insertText(s.textContent, h - 1), t.tr.setSelection(
          new Q(t.doc.resolve(h - 1))
        )), !0;
      },
      // Splits a block at a given position. Content after the position is moved to a new block below, at the same
      // nesting level.
      BNSplitBlock: (o, t) => ({ state: e, dispatch: r }) => {
        const n = g(e.doc, o);
        if (n === void 0)
          return !1;
        const { contentNode: i, contentType: a, startPos: s, endPos: l, depth: d } = n, c = e.doc.cut(s + 1, o), h = e.doc.cut(o, l - 1), f = e.schema.nodes.blockContainer.createAndFill(), p = l + 1, m = p + 2;
        return r && (e.tr.insert(p, f), e.tr.replace(
          m,
          m + 1,
          h.content.size > 0 ? new P(
            L.from(h),
            d + 2,
            d + 2
          ) : void 0
        ), t && e.tr.setBlockType(
          m,
          m,
          e.schema.node(a).type,
          i.attrs
        ), e.tr.setSelection(
          new Q(e.doc.resolve(m))
        ), e.tr.replace(
          s + 1,
          l - 1,
          c.content.size > 0 ? new P(
            L.from(c),
            d + 2,
            d + 2
          ) : void 0
        )), !0;
      }
    };
  },
  addProseMirrorPlugins() {
    return [ge()];
  },
  addKeyboardShortcuts() {
    return {
      Backspace: () => this.editor.commands.first(({ commands: e }) => [
        // Deletes the selection if it's not empty.
        () => e.deleteSelection(),
        // Undoes an input rule if one was triggered in the last editor state change.
        () => e.undoInputRule(),
        // Reverts block content type to a paragraph if the selection is at the start of the block.
        () => e.command(({ state: r }) => {
          const { contentType: n } = g(
            r.doc,
            r.selection.from
          ), i = r.selection.$anchor.parentOffset === 0, a = n.name === "paragraph";
          return i && !a ? e.BNUpdateBlock(r.selection.from, {
            type: "paragraph",
            props: {}
          }) : !1;
        }),
        // Removes a level of nesting if the block is indented if the selection is at the start of the block.
        () => e.command(({ state: r }) => r.selection.$anchor.parentOffset === 0 ? e.liftListItem("blockContainer") : !1),
        // Merges block with the previous one if it isn't indented, isn't the first block in the doc, and the selection
        // is at the start of the block.
        () => e.command(({ state: r }) => {
          const { depth: n, startPos: i } = g(
            r.doc,
            r.selection.from
          ), a = r.selection.$anchor.parentOffset === 0, s = r.selection.anchor === r.selection.head, l = i === 2, d = i - 1;
          return !l && a && s && n === 2 ? e.BNMergeBlocks(d) : !1;
        })
      ]),
      Enter: () => this.editor.commands.first(({ commands: e }) => [
        // Removes a level of nesting if the block is empty & indented, while the selection is also empty & at the start
        // of the block.
        () => e.command(({ state: r }) => {
          const { node: n, depth: i } = g(
            r.doc,
            r.selection.from
          ), a = r.selection.$anchor.parentOffset === 0, s = r.selection.anchor === r.selection.head, l = n.textContent.length === 0, d = i > 2;
          return a && s && l && d ? e.liftListItem("blockContainer") : !1;
        }),
        // Creates a new block and moves the selection to it if the current one is empty, while the selection is also
        // empty & at the start of the block.
        () => e.command(({ state: r, chain: n }) => {
          const { node: i, endPos: a } = g(
            r.doc,
            r.selection.from
          ), s = r.selection.$anchor.parentOffset === 0, l = r.selection.anchor === r.selection.head, d = i.textContent.length === 0;
          if (s && l && d) {
            const c = a + 1, h = c + 2;
            return n().BNCreateBlock(c).setTextSelection(h).run(), !0;
          }
          return !1;
        }),
        // Splits the current block, moving content inside that's after the cursor to a new text block below. Also
        // deletes the selection beforehand, if it's not empty.
        () => e.command(({ state: r, chain: n }) => {
          const { node: i } = g(
            r.doc,
            r.selection.from
          );
          return i.textContent.length === 0 ? !1 : (n().deleteSelection().BNSplitBlock(r.selection.from, !1).run(), !0);
        })
      ]),
      // Always returning true for tab key presses ensures they're not captured by the browser. Otherwise, they blur the
      // editor since the browser will try to use tab for keyboard navigation.
      Tab: () => (this.editor.commands.sinkListItem("blockContainer"), !0),
      "Shift-Tab": () => (this.editor.commands.liftListItem("blockContainer"), !0),
      "Mod-Alt-0": () => this.editor.commands.BNCreateBlock(
        this.editor.state.selection.anchor + 2
      ),
      "Mod-Alt-1": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {
        type: "heading",
        props: {
          level: "1"
        }
      }),
      "Mod-Alt-2": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {
        type: "heading",
        props: {
          level: "2"
        }
      }),
      "Mod-Alt-3": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {
        type: "heading",
        props: {
          level: "3"
        }
      }),
      "Mod-Shift-7": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {
        type: "bulletListItem",
        props: {}
      }),
      "Mod-Shift-8": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {
        type: "numberedListItem",
        props: {}
      })
    };
  }
}), we = S.create({
  name: "blockGroup",
  group: "blockGroup",
  content: "blockContainer+",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "div",
        getAttrs: (o) => typeof o == "string" ? !1 : o.getAttribute("data-node-type") === "blockGroup" ? null : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: o }) {
    return [
      "div",
      w(this.options.HTMLAttributes, o, {
        class: b.blockGroup,
        "data-node-type": "blockGroup"
      }),
      0
    ];
  }
}), Se = S.create({
  name: "paragraph",
  group: "blockContent",
  content: "inline*",
  parseHTML() {
    return [
      {
        tag: "p",
        priority: 200,
        node: "paragraph"
      }
    ];
  },
  renderHTML({ HTMLAttributes: o }) {
    return [
      "div",
      w(o, {
        class: b.blockContent,
        "data-content-type": this.name
      }),
      ["p", 0]
    ];
  }
}), xe = S.create({
  name: "heading",
  group: "blockContent",
  content: "inline*",
  addAttributes() {
    return {
      level: {
        default: "1",
        // instead of "level" attributes, use "data-level"
        parseHTML: (o) => o.getAttribute("data-level"),
        renderHTML: (o) => ({
          "data-level": o.level
        })
      }
    };
  },
  addInputRules() {
    return [
      ...["1", "2", "3"].map((o) => new j({
        find: new RegExp(`^(#{${parseInt(o)}})\\s$`),
        handler: ({ state: t, chain: e, range: r }) => {
          e().BNUpdateBlock(t.selection.from, {
            type: "heading",
            props: {
              level: o
            }
          }).deleteRange({ from: r.from, to: r.to });
        }
      }))
    ];
  },
  parseHTML() {
    return [
      {
        tag: "h1",
        attrs: { level: "1" },
        node: "heading"
      },
      {
        tag: "h2",
        attrs: { level: "2" },
        node: "heading"
      },
      {
        tag: "h3",
        attrs: { level: "3" },
        node: "heading"
      }
    ];
  },
  renderHTML({ node: o, HTMLAttributes: t }) {
    return [
      "div",
      w(t, {
        class: b.blockContent,
        "data-content-type": this.name
      }),
      ["h" + o.attrs.level, 0]
    ];
  }
}), kt = (o) => {
  const { node: t, contentType: e } = g(
    o.state.doc,
    o.state.selection.from
  ), r = o.state.selection.anchor === o.state.selection.head;
  return !e.name.endsWith("ListItem") || !r ? !1 : o.commands.first(({ state: n, chain: i, commands: a }) => [
    () => (
      // Changes list item block to a text block if the content is empty.
      a.command(() => t.textContent.length === 0 ? a.BNUpdateBlock(n.selection.from, {
        type: "paragraph",
        props: {}
      }) : !1)
    ),
    () => (
      // Splits the current block, moving content inside that's after the cursor to a new block of the same type
      // below.
      a.command(() => t.textContent.length > 0 ? (i().deleteSelection().BNSplitBlock(n.selection.from, !0).run(), !0) : !1)
    )
  ]);
}, Ie = S.create({
  name: "bulletListItem",
  group: "blockContent",
  content: "inline*",
  addInputRules() {
    return [
      // Creates an unordered list when starting with "-", "+", or "*".
      new j({
        find: new RegExp("^[-+*]\\s$"),
        handler: ({ state: o, chain: t, range: e }) => {
          t().BNUpdateBlock(o.selection.from, {
            type: "bulletListItem",
            props: {}
          }).deleteRange({ from: e.from, to: e.to });
        }
      })
    ];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => kt(this.editor)
    };
  },
  parseHTML() {
    return [
      // Case for regular HTML list structure.
      {
        tag: "li",
        getAttrs: (o) => {
          if (typeof o == "string")
            return !1;
          const t = o.parentElement;
          return t === null ? !1 : t.tagName === "UL" ? {} : !1;
        },
        node: "bulletListItem"
      },
      // Case for BlockNote list structure.
      {
        tag: "p",
        getAttrs: (o) => {
          if (typeof o == "string")
            return !1;
          const t = o.parentElement;
          return t === null ? !1 : t.getAttribute("data-content-type") === "bulletListItem" ? {} : !1;
        },
        priority: 300,
        node: "bulletListItem"
      }
    ];
  },
  renderHTML({ HTMLAttributes: o }) {
    return [
      "div",
      w(o, {
        class: b.blockContent,
        "data-content-type": this.name
      }),
      ["p", 0]
    ];
  }
}), Pe = new v("numbered-list-indexing"), Le = () => new C({
  key: Pe,
  appendTransaction: (o, t, e) => {
    const r = e.tr;
    r.setMeta("numberedListIndexing", !0);
    let n = !1;
    return e.doc.descendants((i, a) => {
      if (i.type.name === "blockContainer" && i.firstChild.type.name === "numberedListItem") {
        let s = "1";
        const l = a === 1, d = g(r.doc, a + 1);
        if (d === void 0)
          return;
        if (!l) {
          const f = g(r.doc, a - 2);
          if (f === void 0)
            return;
          if (!(d.depth !== f.depth)) {
            const m = f.contentNode;
            if (f.contentType.name === "numberedListItem") {
              const z = m.attrs.index;
              s = (parseInt(z) + 1).toString();
            }
          }
        }
        d.contentNode.attrs.index !== s && (n = !0, r.setNodeMarkup(a + 1, void 0, {
          index: s
        }));
      }
    }), n ? r : null;
  }
}), _e = S.create({
  name: "numberedListItem",
  group: "blockContent",
  content: "inline*",
  addAttributes() {
    return {
      index: {
        default: null,
        parseHTML: (o) => o.getAttribute("data-index"),
        renderHTML: (o) => ({
          "data-index": o.index
        })
      }
    };
  },
  addInputRules() {
    return [
      // Creates an ordered list when starting with "1.".
      new j({
        find: new RegExp("^1\\.\\s$"),
        handler: ({ state: o, chain: t, range: e }) => {
          t().BNUpdateBlock(o.selection.from, {
            type: "numberedListItem",
            props: {}
          }).deleteRange({ from: e.from, to: e.to });
        }
      })
    ];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => kt(this.editor)
    };
  },
  addProseMirrorPlugins() {
    return [Le()];
  },
  parseHTML() {
    return [
      // Case for regular HTML list structure.
      // (e.g.: when pasting from other apps)
      {
        tag: "li",
        getAttrs: (o) => {
          if (typeof o == "string")
            return !1;
          const t = o.parentElement;
          return t === null ? !1 : t.tagName === "OL" ? {} : !1;
        },
        node: "numberedListItem"
      },
      // Case for BlockNote list structure.
      // (e.g.: when pasting from blocknote)
      {
        tag: "p",
        getAttrs: (o) => {
          if (typeof o == "string")
            return !1;
          const t = o.parentElement;
          return t === null ? !1 : t.getAttribute("data-content-type") === "numberedListItem" ? {} : !1;
        },
        priority: 300,
        node: "numberedListItem"
      }
    ];
  },
  renderHTML({ HTMLAttributes: o }) {
    return [
      "div",
      w(o, {
        class: b.blockContent,
        "data-content-type": this.name
      }),
      // we use a <p> tag, because for <li> tags we'd need to add a <ul> parent for around siblings to be semantically correct,
      // which would be quite cumbersome
      ["p", 0]
    ];
  }
}), Ae = [
  Se,
  xe,
  Ie,
  _e,
  Te,
  we,
  S.create({
    name: "doc",
    topNode: !0,
    content: "blockGroup"
  })
], Ne = wt(
  (o) => o.type.name === "blockContainer"
);
function q() {
  return {
    active: !1,
    triggerCharacter: void 0,
    queryStartPos: void 0,
    items: [],
    keyboardHoveredItemIndex: void 0,
    notFoundCount: 0,
    decorationId: void 0
  };
}
class He {
  constructor({
    editor: t,
    pluginKey: e,
    onSelectItem: r = () => {
    },
    suggestionsMenuFactory: n
  }) {
    u(this, "editor");
    u(this, "pluginKey");
    u(this, "suggestionsMenu");
    u(this, "pluginState");
    u(this, "itemCallback");
    u(this, "handleScroll", () => {
      this.pluginKey.getState(this.editor._tiptapEditor.state).active && this.suggestionsMenu.render(this.getDynamicParams(), !1);
    });
    this.editor = t, this.pluginKey = e, this.pluginState = q(), this.itemCallback = (i) => {
      t._tiptapEditor.chain().focus().deleteRange({
        from: this.pluginState.queryStartPos - this.pluginState.triggerCharacter.length,
        to: t._tiptapEditor.state.selection.from
      }).run(), r({
        item: i,
        editor: t
      });
    }, this.suggestionsMenu = n(this.getStaticParams()), document.addEventListener("scroll", this.handleScroll);
  }
  update(t, e) {
    const r = this.pluginKey.getState(e), n = this.pluginKey.getState(t.state), i = !r.active && n.active, a = r.active && !n.active, s = r.active && n.active;
    !i && !s && !a || (this.pluginState = a ? r : n, (a || !this.editor.isEditable) && (this.suggestionsMenu.hide(), this.suggestionsMenu.element.removeEventListener(
      "mousedown",
      (l) => l.preventDefault()
    )), s && this.suggestionsMenu.render(this.getDynamicParams(), !1), i && this.editor.isEditable && (this.suggestionsMenu.render(this.getDynamicParams(), !0), this.suggestionsMenu.element.addEventListener(
      "mousedown",
      (l) => l.preventDefault()
    )));
  }
  destroy() {
    document.removeEventListener("scroll", this.handleScroll);
  }
  getStaticParams() {
    return {
      itemCallback: (t) => this.itemCallback(t)
    };
  }
  getDynamicParams() {
    const t = document.querySelector(
      `[data-decoration-id="${this.pluginState.decorationId}"]`
    );
    return {
      items: this.pluginState.items,
      keyboardHoveredItemIndex: this.pluginState.keyboardHoveredItemIndex,
      referenceRect: t.getBoundingClientRect()
    };
  }
}
function Oe({
  pluginKey: o,
  editor: t,
  defaultTriggerCharacter: e,
  suggestionsMenuFactory: r,
  onSelectItem: n = () => {
  },
  items: i = () => []
}) {
  if (e.length !== 1)
    throw new Error("'char' should be a single character");
  const a = (s) => {
    s.dispatch(s.state.tr.setMeta(o, { deactivate: !0 }));
  };
  return new C({
    key: o,
    view: (s) => new He({
      editor: t,
      pluginKey: o,
      onSelectItem: (l) => {
        a(s), n(l);
      },
      suggestionsMenuFactory: r
    }),
    state: {
      // Initialize the plugin's internal state.
      init() {
        return q();
      },
      // Apply changes to the plugin state from an editor transaction.
      apply(s, l, d, c) {
        var f, p, m, y;
        if (s.getMeta("orderedListIndexing") !== void 0)
          return l;
        if ((f = s.getMeta(o)) != null && f.activate)
          return {
            active: !0,
            triggerCharacter: ((p = s.getMeta(o)) == null ? void 0 : p.triggerCharacter) || "",
            queryStartPos: c.selection.from,
            items: i(""),
            keyboardHoveredItemIndex: 0,
            // TODO: Maybe should be 1 if the menu has no possible items? Probably redundant since a menu with no items
            //  is useless in practice.
            notFoundCount: 0,
            decorationId: `id_${Math.floor(Math.random() * 4294967295)}`
          };
        if (!l.active)
          return l;
        const h = { ...l };
        if (h.items = i(
          c.doc.textBetween(l.queryStartPos, c.selection.from)
        ), h.notFoundCount = 0, h.items.length === 0 && (h.notFoundCount = Math.max(
          0,
          l.notFoundCount + (c.selection.from - d.selection.from)
        )), // Highlighting text should hide the menu.
        c.selection.from !== c.selection.to || // Transactions with plugin metadata {deactivate: true} should hide the menu.
        (m = s.getMeta(o)) != null && m.deactivate || // Certain mouse events should hide the menu.
        // TODO: Change to global mousedown listener.
        s.getMeta("focus") || s.getMeta("blur") || s.getMeta("pointer") || // Moving the caret before the character which triggered the menu should hide it.
        l.active && c.selection.from < l.queryStartPos || // Entering more than 3 characters, after the last query that matched with at least 1 menu item, should hide
        // the menu.
        h.notFoundCount > 3)
          return q();
        if (((y = s.getMeta(o)) == null ? void 0 : y.selectedItemIndexChanged) !== void 0) {
          let k = s.getMeta(o).selectedItemIndexChanged;
          k < 0 ? k = l.items.length - 1 : k >= l.items.length && (k = 0), h.keyboardHoveredItemIndex = k;
        }
        return h;
      }
    },
    props: {
      handleKeyDown(s, l) {
        const d = this.getState(s.state).active;
        if (l.key === e && !d)
          return s.dispatch(
            s.state.tr.insertText(e).scrollIntoView().setMeta(o, {
              activate: !0,
              triggerCharacter: e
            })
          ), !0;
        if (!d)
          return !1;
        const {
          triggerCharacter: c,
          queryStartPos: h,
          items: f,
          keyboardHoveredItemIndex: p
        } = o.getState(s.state);
        return l.key === "ArrowUp" ? (s.dispatch(
          s.state.tr.setMeta(o, {
            selectedItemIndexChanged: p - 1
          })
        ), !0) : l.key === "ArrowDown" ? (s.dispatch(
          s.state.tr.setMeta(o, {
            selectedItemIndexChanged: p + 1
          })
        ), !0) : l.key === "Enter" ? (a(s), t._tiptapEditor.chain().focus().deleteRange({
          from: h - c.length,
          to: t._tiptapEditor.state.selection.from
        }).run(), n({
          item: f[p],
          editor: t
        }), !0) : l.key === "Escape" ? (a(s), !0) : !1;
      },
      // Hides menu in cases where mouse click does not cause an editor state change.
      handleClick(s) {
        a(s);
      },
      // Setup decorator on the currently active suggestion.
      decorations(s) {
        const { active: l, decorationId: d, queryStartPos: c, triggerCharacter: h } = this.getState(s);
        if (!l)
          return null;
        if (h === "") {
          const f = Ne(s.selection);
          if (f)
            return F.create(s.doc, [
              D.node(
                f.pos,
                f.pos + f.node.nodeSize,
                {
                  nodeName: "span",
                  class: "suggestion-decorator",
                  "data-decoration-id": d
                }
              )
            ]);
        }
        return F.create(s.doc, [
          D.inline(
            c - h.length,
            c,
            {
              nodeName: "span",
              class: "suggestion-decorator",
              "data-decoration-id": d
            }
          )
        ]);
      }
    }
  });
}
const V = new v("suggestions-slash-commands"), De = E.create({
  name: "slash-command",
  addOptions() {
    return {
      editor: void 0,
      commands: void 0,
      slashMenuFactory: void 0
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.slashMenuFactory || !this.options.commands)
      throw new Error("required args not defined for SlashMenuExtension");
    const o = this.options.commands;
    return [
      Oe({
        pluginKey: V,
        editor: this.options.editor,
        defaultTriggerCharacter: "/",
        suggestionsMenuFactory: this.options.slashMenuFactory,
        items: (t) => o.filter((e) => e.match(t)),
        onSelectItem: ({ item: t, editor: e }) => {
          t.execute(e);
        }
      })
    ];
  }
});
class A extends $ {
  constructor(e, r) {
    super(e, r);
    u(this, "nodes");
    const n = e.node();
    this.nodes = [], e.doc.nodesBetween(e.pos, r.pos, (i, a, s) => {
      if (s !== null && s.eq(n))
        return this.nodes.push(i), !1;
    });
  }
  static create(e, r, n = r) {
    return new A(e.resolve(r), e.resolve(n));
  }
  content() {
    return new P(L.from(this.nodes), 0, 0);
  }
  eq(e) {
    if (!(e instanceof A) || this.nodes.length !== e.nodes.length || this.from !== e.from || this.to !== e.to)
      return !1;
    for (let r = 0; r < this.nodes.length; r++)
      if (!this.nodes[r].eq(e.nodes[r]))
        return !1;
    return !0;
  }
  map(e, r) {
    let n = r.mapResult(this.from), i = r.mapResult(this.to);
    return i.deleted ? $.near(e.resolve(n.pos)) : n.deleted ? $.near(e.resolve(i.pos)) : new A(
      e.resolve(n.pos),
      e.resolve(i.pos)
    );
  }
  toJSON() {
    return { type: "node", anchor: this.anchor, head: this.head };
  }
}
const Fe = Jt.__serializeForClipboard;
let T;
function yt(o, t) {
  var n;
  if (!t.dom.isConnected)
    return;
  let e = t.posAtCoords(o);
  if (!e)
    return;
  let r = t.domAtPos(e.pos).node;
  if (r !== t.dom) {
    for (; r && r.parentNode && r.parentNode !== t.dom && !((n = r.hasAttribute) != null && n.call(r, "data-id")); )
      r = r.parentNode;
    if (r)
      return { node: r, id: r.getAttribute("data-id") };
  }
}
function Re(o, t) {
  let e = yt(o, t);
  if (e && e.node.nodeType === 1) {
    const r = t.docView;
    let n = r.nearestDesc(e.node, !0);
    return !n || n === r ? null : n.posBefore;
  }
  return null;
}
function ze(o, t) {
  let e, r;
  const n = t.resolve(o.from).node().type.spec.group === "blockContent", i = t.resolve(o.to).node().type.spec.group === "blockContent", a = Math.min(o.$anchor.depth, o.$head.depth);
  if (n && i) {
    const s = o.$from.start(a - 1), l = o.$to.end(a - 1);
    e = t.resolve(s - 1).pos, r = t.resolve(l + 1).pos;
  } else
    e = o.from, r = o.to;
  return { from: e, to: r };
}
function ot(o, t, e = t) {
  t === e && (e += o.state.doc.resolve(t + 1).node().nodeSize);
  const r = o.domAtPos(t).node.cloneNode(!0), n = o.domAtPos(t).node, i = (c, h) => Array.prototype.indexOf.call(c.children, h), a = i(
    n,
    // Expects from position to be just before the first selected block.
    o.domAtPos(t + 1).node.parentElement
  ), s = i(
    n,
    // Expects to position to be just after the last selected block.
    o.domAtPos(e - 1).node.parentElement
  );
  for (let c = n.childElementCount - 1; c >= 0; c--)
    (c > s || c < a) && r.removeChild(r.children[c]);
  bt(), T = r;
  const d = o.dom.className.split(" ").filter(
    (c) => !c.includes("bn") && !c.includes("ProseMirror") && !c.includes("editor")
  ).join(" ");
  T.className = T.className + " " + _.dragPreview + " " + d, document.body.appendChild(T);
}
function bt() {
  T !== void 0 && (document.body.removeChild(T), T = void 0);
}
function Ue(o, t) {
  if (!o.dataTransfer)
    return;
  const e = t.dom.getBoundingClientRect();
  let r = {
    left: e.left + e.width / 2,
    // take middle of editor
    top: o.clientY
  }, n = Re(r, t);
  if (n != null) {
    const i = t.state.selection, a = t.state.doc, { from: s, to: l } = ze(i, a), d = s <= n && n < l, c = i.$anchor.node() !== i.$head.node() || i instanceof A;
    d && c ? (t.dispatch(
      t.state.tr.setSelection(A.create(a, s, l))
    ), ot(t, s, l)) : (t.dispatch(
      t.state.tr.setSelection(_t.create(t.state.doc, n))
    ), ot(t, n));
    let h = t.state.selection.content(), { dom: f, text: p } = Fe(t, h);
    o.dataTransfer.clearData(), o.dataTransfer.setData("text/html", f.innerHTML), o.dataTransfer.setData("text/plain", p), o.dataTransfer.effectAllowed = "move", o.dataTransfer.setDragImage(T, 0, 0), t.dragging = { slice: h, move: !0 };
  }
}
class $e {
  constructor({
    tiptapEditor: t,
    editor: e,
    blockMenuFactory: r,
    horizontalPosAnchoredAtRoot: n
  }) {
    u(this, "editor");
    u(this, "ttEditor");
    // When true, the drag handle with be anchored at the same level as root elements
    // When false, the drag handle with be just to the left of the element
    u(this, "horizontalPosAnchoredAtRoot");
    u(this, "horizontalPosAnchor");
    u(this, "blockMenu");
    u(this, "hoveredBlock");
    // Used to check if currently dragged content comes from this editor instance.
    u(this, "isDragging", !1);
    u(this, "menuOpen", !1);
    u(this, "menuFrozen", !1);
    /**
     * Sets isDragging when dragging text.
     */
    u(this, "onDragStart", () => {
      this.isDragging = !0;
    });
    /**
     * If the event is outside the editor contents,
     * we dispatch a fake event, so that we can still drop the content
     * when dragging / dropping to the side of the editor
     */
    u(this, "onDrop", (t) => {
      if (t.synthetic || !this.isDragging)
        return;
      let e = this.ttEditor.view.posAtCoords({
        left: t.clientX,
        top: t.clientY
      });
      if (this.isDragging = !1, !e || e.inside === -1) {
        const r = new Event("drop", t), n = this.ttEditor.view.dom.firstChild.getBoundingClientRect();
        r.clientX = n.left + n.width / 2, r.clientY = t.clientY, r.dataTransfer = t.dataTransfer, r.preventDefault = () => t.preventDefault(), r.synthetic = !0, this.ttEditor.view.dom.dispatchEvent(r);
      }
    });
    /**
     * If the event is outside of the editor contents,
     * we dispatch a fake event, so that we can still drop the content
     * when dragging / dropping to the side of the editor
     */
    u(this, "onDragOver", (t) => {
      if (t.synthetic || !this.isDragging)
        return;
      let e = this.ttEditor.view.posAtCoords({
        left: t.clientX,
        top: t.clientY
      });
      if (!e || e.inside === -1) {
        const r = new Event("dragover", t), n = this.ttEditor.view.dom.firstChild.getBoundingClientRect();
        r.clientX = n.left + n.width / 2, r.clientY = t.clientY, r.dataTransfer = t.dataTransfer, r.preventDefault = () => t.preventDefault(), r.synthetic = !0, this.ttEditor.view.dom.dispatchEvent(r);
      }
    });
    u(this, "onKeyDown", (t) => {
      this.menuOpen && (this.menuOpen = !1, this.blockMenu.hide()), this.menuFrozen = !1;
    });
    u(this, "onMouseDown", (t) => {
      var e;
      (e = this.blockMenu.element) != null && e.contains(t.target) || (this.menuOpen && (this.menuOpen = !1, this.blockMenu.hide()), this.menuFrozen = !1);
    });
    u(this, "onMouseMove", (t) => {
      var a, s;
      if (this.menuFrozen)
        return;
      const e = this.ttEditor.view.dom.firstChild.getBoundingClientRect();
      this.horizontalPosAnchor = e.x;
      const r = {
        left: e.left + e.width / 2,
        // take middle of editor
        top: t.clientY
      }, n = yt(r, this.ttEditor.view);
      if (!n || !this.editor.isEditable) {
        this.menuOpen && (this.menuOpen = !1, this.blockMenu.hide());
        return;
      }
      this.menuOpen && ((a = this.hoveredBlock) != null && a.hasAttribute("data-id")) && ((s = this.hoveredBlock) == null ? void 0 : s.getAttribute("data-id")) === n.id || (this.hoveredBlock = n.node, !n.node.firstChild) || this.editor.isEditable && (this.menuOpen ? this.blockMenu.render(this.getDynamicParams(), !1) : (this.menuOpen = !0, this.blockMenu.render(this.getDynamicParams(), !0)));
    });
    u(this, "onScroll", () => {
      this.menuOpen && this.blockMenu.render(this.getDynamicParams(), !1);
    });
    this.editor = e, this.ttEditor = t, this.horizontalPosAnchoredAtRoot = n, this.horizontalPosAnchor = this.ttEditor.view.dom.firstChild.getBoundingClientRect().x, this.blockMenu = r(this.getStaticParams()), document.body.addEventListener("drop", this.onDrop, !0), document.body.addEventListener("dragover", this.onDragOver), this.ttEditor.view.dom.addEventListener("dragstart", this.onDragStart), document.body.addEventListener("mousemove", this.onMouseMove, !0), document.addEventListener("scroll", this.onScroll), document.body.addEventListener("mousedown", this.onMouseDown, !0), document.body.addEventListener("keydown", this.onKeyDown, !0);
  }
  destroy() {
    this.menuOpen && (this.menuOpen = !1, this.blockMenu.hide()), document.body.removeEventListener("mousemove", this.onMouseMove), document.body.removeEventListener("dragover", this.onDragOver), this.ttEditor.view.dom.removeEventListener("dragstart", this.onDragStart), document.body.removeEventListener("drop", this.onDrop), document.body.removeEventListener("mousedown", this.onMouseDown), document.removeEventListener("scroll", this.onScroll), document.body.removeEventListener("keydown", this.onKeyDown);
  }
  addBlock() {
    this.menuOpen = !1, this.menuFrozen = !0, this.blockMenu.hide();
    const e = this.hoveredBlock.firstChild.getBoundingClientRect(), r = this.ttEditor.view.posAtCoords({
      left: e.left + e.width / 2,
      top: e.top + e.height / 2
    });
    if (!r)
      return;
    const n = g(this.ttEditor.state.doc, r.pos);
    if (n === void 0)
      return;
    const { contentNode: i, endPos: a } = n;
    if (i.textContent.length !== 0) {
      const s = a + 1, l = s + 2;
      this.ttEditor.chain().BNCreateBlock(s).BNUpdateBlock(l, { type: "paragraph", props: {} }).setTextSelection(l).run();
    } else
      this.ttEditor.commands.setTextSelection(a);
    this.ttEditor.view.focus(), this.ttEditor.view.dispatch(
      this.ttEditor.view.state.tr.scrollIntoView().setMeta(V, {
        // TODO import suggestion plugin key
        activate: !0,
        type: "drag"
      })
    );
  }
  getStaticParams() {
    return {
      editor: this.editor,
      addBlock: () => this.addBlock(),
      blockDragStart: (t) => {
        this.isDragging = !0, Ue(t, this.ttEditor.view);
      },
      blockDragEnd: () => bt(),
      freezeMenu: () => {
        this.menuFrozen = !0;
      },
      unfreezeMenu: () => {
        this.menuFrozen = !1;
      }
    };
  }
  getDynamicParams() {
    const e = this.hoveredBlock.firstChild.getBoundingClientRect();
    return {
      block: this.editor.getBlock(this.hoveredBlock.getAttribute("data-id")),
      referenceRect: new DOMRect(
        this.horizontalPosAnchoredAtRoot ? this.horizontalPosAnchor : e.x,
        e.y,
        e.width,
        e.height
      )
    };
  }
}
const Ge = (o) => new C({
  key: new v("DraggableBlocksPlugin"),
  view: () => new $e({
    tiptapEditor: o.tiptapEditor,
    editor: o.editor,
    blockMenuFactory: o.blockSideMenuFactory,
    horizontalPosAnchoredAtRoot: !0
  })
}), qe = E.create({
  name: "DraggableBlocksExtension",
  priority: 1e3,
  // Need to be high, in order to hide menu when typing slash
  addProseMirrorPlugins() {
    if (!this.options.blockSideMenuFactory)
      throw new Error(
        "UI Element factory not defined for DraggableBlocksExtension"
      );
    return [
      Ge({
        tiptapEditor: this.editor,
        editor: this.options.editor,
        blockSideMenuFactory: this.options.blockSideMenuFactory
      })
    ];
  }
});
class je {
  constructor({
    editor: t,
    tiptapEditor: e,
    formattingToolbarFactory: r,
    view: n,
    shouldShow: i
  }) {
    u(this, "editor");
    u(this, "ttEditor");
    u(this, "view");
    u(this, "formattingToolbar");
    u(this, "preventHide", !1);
    u(this, "preventShow", !1);
    u(this, "toolbarIsOpen", !1);
    u(this, "prevWasEditable", null);
    u(this, "shouldShow", ({ view: t, state: e, from: r, to: n }) => {
      const { doc: i, selection: a } = e, { empty: s } = a, l = !i.textBetween(r, n).length && St(e.selection);
      return !(!t.hasFocus() || s || l);
    });
    u(this, "viewMousedownHandler", () => {
      this.preventShow = !0;
    });
    u(this, "viewMouseupHandler", () => {
      this.preventShow = !1, setTimeout(() => this.update(this.ttEditor.view));
    });
    u(this, "dragstartHandler", () => {
      this.formattingToolbar.hide(), this.toolbarIsOpen = !1;
    });
    u(this, "focusHandler", () => {
      setTimeout(() => this.update(this.ttEditor.view));
    });
    u(this, "blurHandler", ({ event: t }) => {
      var e, r;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      t != null && t.relatedTarget && ((r = (e = this.formattingToolbar.element) == null ? void 0 : e.parentNode) != null && r.contains(
        t.relatedTarget
      )) || this.toolbarIsOpen && (this.formattingToolbar.hide(), this.toolbarIsOpen = !1);
    });
    u(this, "scrollHandler", () => {
      this.toolbarIsOpen && this.formattingToolbar.render(this.getDynamicParams(), !1);
    });
    this.editor = t, this.ttEditor = e, this.view = n, this.formattingToolbar = r(this.getStaticParams()), i && (this.shouldShow = i), this.view.dom.addEventListener("mousedown", this.viewMousedownHandler), this.view.dom.addEventListener("mouseup", this.viewMouseupHandler), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.ttEditor.on("focus", this.focusHandler), this.ttEditor.on("blur", this.blurHandler), document.addEventListener("scroll", this.scrollHandler);
  }
  update(t, e) {
    var f;
    const { state: r, composing: n } = t, { doc: i, selection: a } = r, s = e && e.doc.eq(i) && e.selection.eq(a);
    if ((this.prevWasEditable === null || this.prevWasEditable === this.editor.isEditable) && (n || s))
      return;
    this.prevWasEditable = this.editor.isEditable;
    const { ranges: l } = a, d = Math.min(...l.map((p) => p.$from.pos)), c = Math.max(...l.map((p) => p.$to.pos)), h = (f = this.shouldShow) == null ? void 0 : f.call(this, {
      editor: this.editor,
      view: t,
      state: r,
      oldState: e,
      from: d,
      to: c
    });
    if (this.editor.isEditable && !this.toolbarIsOpen && !this.preventShow && (h || this.preventHide)) {
      this.formattingToolbar.render(this.getDynamicParams(), !0), this.toolbarIsOpen = !0, this.formattingToolbar.element.addEventListener(
        "mousedown",
        (p) => p.preventDefault()
      );
      return;
    }
    if (this.toolbarIsOpen && !this.preventShow && (h || this.preventHide)) {
      this.formattingToolbar.render(this.getDynamicParams(), !1);
      return;
    }
    if (this.toolbarIsOpen && !this.preventHide && (!h || this.preventShow || !this.editor.isEditable)) {
      this.formattingToolbar.hide(), this.toolbarIsOpen = !1, this.formattingToolbar.element.removeEventListener(
        "mousedown",
        (p) => p.preventDefault()
      );
      return;
    }
  }
  destroy() {
    this.view.dom.removeEventListener("mousedown", this.viewMousedownHandler), this.view.dom.removeEventListener("mouseup", this.viewMouseupHandler), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.ttEditor.off("focus", this.focusHandler), this.ttEditor.off("blur", this.blurHandler), document.removeEventListener("scroll", this.scrollHandler);
  }
  getSelectionBoundingBox() {
    const { state: t } = this.ttEditor.view, { selection: e } = t, { ranges: r } = e, n = Math.min(...r.map((a) => a.$from.pos)), i = Math.max(...r.map((a) => a.$to.pos));
    if (xt(e)) {
      const a = this.ttEditor.view.nodeDOM(n);
      if (a)
        return a.getBoundingClientRect();
    }
    return nt(this.ttEditor.view, n, i);
  }
  getStaticParams() {
    return {
      editor: this.editor
    };
  }
  getDynamicParams() {
    return {
      referenceRect: this.getSelectionBoundingBox()
    };
  }
}
const We = (o) => new C({
  key: new v("FormattingToolbarPlugin"),
  view: (t) => new je({ view: t, ...o })
}), Ye = E.create({
  name: "FormattingToolbarExtension",
  addProseMirrorPlugins() {
    if (!this.options.formattingToolbarFactory || !this.options.editor)
      throw new Error(
        "required args not defined for FormattingToolbarExtension"
      );
    return [
      We({
        tiptapEditor: this.editor,
        editor: this.options.editor,
        formattingToolbarFactory: this.options.formattingToolbarFactory,
        pluginKey: new v("FormattingToolbarPlugin")
      })
    ];
  }
}), Ke = new v("HyperlinkToolbarPlugin");
class Ve {
  constructor({ editor: t, hyperlinkToolbarFactory: e }) {
    u(this, "editor");
    u(this, "hyperlinkToolbar");
    u(this, "menuUpdateTimer");
    u(this, "startMenuUpdateTimer");
    u(this, "stopMenuUpdateTimer");
    u(this, "mouseHoveredHyperlinkMark");
    u(this, "mouseHoveredHyperlinkMarkRange");
    u(this, "keyboardHoveredHyperlinkMark");
    u(this, "keyboardHoveredHyperlinkMarkRange");
    u(this, "hyperlinkMark");
    u(this, "hyperlinkMarkRange");
    u(this, "mouseOverHandler", (t) => {
      if (this.mouseHoveredHyperlinkMark = void 0, this.mouseHoveredHyperlinkMarkRange = void 0, this.stopMenuUpdateTimer(), t.target instanceof HTMLAnchorElement && t.target.nodeName === "A") {
        const e = t.target, r = this.editor.view.posAtDOM(e, 0) + 1, n = this.editor.state.doc.resolve(
          r
        ), i = n.marks();
        for (const a of i)
          if (a.type.name === this.editor.schema.mark("link").type.name) {
            this.mouseHoveredHyperlinkMark = a, this.mouseHoveredHyperlinkMarkRange = X(
              n,
              a.type,
              a.attrs
            ) || void 0;
            break;
          }
      }
      return this.startMenuUpdateTimer(), !1;
    });
    u(this, "scrollHandler", () => {
      this.hyperlinkMark !== void 0 && this.hyperlinkToolbar.render(this.getDynamicParams(), !1);
    });
    this.editor = t, this.hyperlinkToolbar = e(this.getStaticParams()), this.startMenuUpdateTimer = () => {
      this.menuUpdateTimer = setTimeout(() => {
        this.update();
      }, 250);
    }, this.stopMenuUpdateTimer = () => (this.menuUpdateTimer && (clearTimeout(this.menuUpdateTimer), this.menuUpdateTimer = void 0), !1), this.editor.view.dom.addEventListener("mouseover", this.mouseOverHandler), document.addEventListener("scroll", this.scrollHandler);
  }
  update() {
    var e, r, n, i;
    if (!this.editor.view.hasFocus())
      return;
    const t = this.hyperlinkMark;
    if (this.hyperlinkMark = void 0, this.hyperlinkMarkRange = void 0, this.keyboardHoveredHyperlinkMark = void 0, this.keyboardHoveredHyperlinkMarkRange = void 0, this.editor.state.selection.empty) {
      const a = this.editor.state.selection.$from.marks();
      for (const s of a)
        if (s.type.name === this.editor.schema.mark("link").type.name) {
          this.keyboardHoveredHyperlinkMark = s, this.keyboardHoveredHyperlinkMarkRange = X(
            this.editor.state.selection.$from,
            s.type,
            s.attrs
          ) || void 0;
          break;
        }
    }
    if (this.mouseHoveredHyperlinkMark && (this.hyperlinkMark = this.mouseHoveredHyperlinkMark, this.hyperlinkMarkRange = this.mouseHoveredHyperlinkMarkRange), this.keyboardHoveredHyperlinkMark && (this.hyperlinkMark = this.keyboardHoveredHyperlinkMark, this.hyperlinkMarkRange = this.keyboardHoveredHyperlinkMarkRange), this.hyperlinkMark && this.editor.isEditable) {
      if (this.getDynamicParams(), !t) {
        this.hyperlinkToolbar.render(this.getDynamicParams(), !0), (e = this.hyperlinkToolbar.element) == null || e.addEventListener(
          "mouseleave",
          this.startMenuUpdateTimer
        ), (r = this.hyperlinkToolbar.element) == null || r.addEventListener(
          "mouseenter",
          this.stopMenuUpdateTimer
        );
        return;
      }
      this.hyperlinkToolbar.render(this.getDynamicParams(), !1);
      return;
    }
    if (t && (!this.hyperlinkMark || !this.editor.isEditable)) {
      (n = this.hyperlinkToolbar.element) == null || n.removeEventListener(
        "mouseleave",
        this.startMenuUpdateTimer
      ), (i = this.hyperlinkToolbar.element) == null || i.removeEventListener(
        "mouseenter",
        this.stopMenuUpdateTimer
      ), this.hyperlinkToolbar.hide();
      return;
    }
  }
  destroy() {
    this.editor.view.dom.removeEventListener(
      "mouseover",
      this.mouseOverHandler
    ), document.removeEventListener("scroll", this.scrollHandler);
  }
  getStaticParams() {
    return {
      editHyperlink: (t, e) => {
        const r = this.editor.view.state.tr.insertText(
          e,
          this.hyperlinkMarkRange.from,
          this.hyperlinkMarkRange.to
        );
        r.addMark(
          this.hyperlinkMarkRange.from,
          this.hyperlinkMarkRange.from + e.length,
          this.editor.schema.mark("link", { href: t })
        ), this.editor.view.dispatch(r), this.editor.view.focus(), this.hyperlinkToolbar.hide();
      },
      deleteHyperlink: () => {
        this.editor.view.dispatch(
          this.editor.view.state.tr.removeMark(
            this.hyperlinkMarkRange.from,
            this.hyperlinkMarkRange.to,
            this.hyperlinkMark.type
          ).setMeta("preventAutolink", !0)
        ), this.editor.view.focus(), this.hyperlinkToolbar.hide();
      }
    };
  }
  getDynamicParams() {
    return {
      url: this.hyperlinkMark.attrs.href,
      text: this.editor.view.state.doc.textBetween(
        this.hyperlinkMarkRange.from,
        this.hyperlinkMarkRange.to
      ),
      referenceRect: nt(
        this.editor.view,
        this.hyperlinkMarkRange.from,
        this.hyperlinkMarkRange.to
      )
    };
  }
}
const Je = (o, t) => new C({
  key: Ke,
  view: () => new Ve({
    editor: o,
    hyperlinkToolbarFactory: t.hyperlinkToolbarFactory
  })
}), Xe = lt.extend({
  priority: 500,
  addProseMirrorPlugins() {
    var o;
    if (!this.options.hyperlinkToolbarFactory)
      throw new Error("UI Element factory not defined for HyperlinkMark");
    return [
      ...((o = this.parent) == null ? void 0 : o.call(this)) || [],
      Je(this.editor, {
        hyperlinkToolbarFactory: this.options.hyperlinkToolbarFactory
      })
    ];
  }
}), Qe = new v("blocknote-placeholder"), Ze = E.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      isFilterClass: "is-filter",
      hasAnchorClass: "has-anchor",
      placeholder: "Write something …",
      showOnlyWhenEditable: !0,
      showOnlyCurrent: !0,
      includeChildren: !1
    };
  },
  addProseMirrorPlugins() {
    return [
      new C({
        key: Qe,
        props: {
          decorations: (o) => {
            const { doc: t, selection: e } = o, r = V.getState(o), n = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: i } = e, a = [];
            if (n)
              return t.descendants((s, l) => {
                const d = i >= l && i <= l + s.nodeSize, c = !s.isLeaf && !s.childCount;
                if ((d || !this.options.showOnlyCurrent) && c) {
                  const h = [this.options.emptyNodeClass];
                  this.editor.isEmpty && h.push(this.options.emptyEditorClass), d && h.push(this.options.hasAnchorClass), (r == null ? void 0 : r.triggerCharacter) === "" && (r != null && r.active) && h.push(this.options.isFilterClass);
                  const f = D.node(l, l + s.nodeSize, {
                    class: h.join(" ")
                  });
                  a.push(f);
                }
                return this.options.includeChildren;
              }), F.create(t, a);
          }
        }
      })
    ];
  }
});
class to {
  constructor(t, e) {
    this.name = t, this.match = e;
  }
}
class x extends to {
  /**
   * Constructs a new slash-command.
   *
   * @param name The name of the command
   * @param execute The callback for creating a new node
   * @param aliases Aliases for this command
   */
  constructor(t, e, r = []) {
    super(t, (n) => this.name.toLowerCase().startsWith(n.toLowerCase()) || this.aliases.filter(
      (i) => i.toLowerCase().startsWith(n.toLowerCase())
    ).length !== 0), this.name = t, this.execute = e, this.aliases = r;
  }
}
function I(o, t) {
  const e = o.getTextCursorPosition().block;
  e.content.length === 1 && e.content[0].type === "text" && e.content[0].text === "/" || e.content.length === 0 ? o.updateBlock(e, t) : (o.insertBlocks([t], e, "after"), o.setTextCursorPosition(o.getTextCursorPosition().nextBlock));
}
const eo = [
  // Command for creating a level 1 heading
  new x(
    "Heading",
    (o) => I(o, {
      type: "heading",
      props: { level: "1" }
    }),
    ["h", "heading1", "h1"]
  ),
  // Command for creating a level 2 heading
  new x(
    "Heading 2",
    (o) => I(o, {
      type: "heading",
      props: { level: "2" }
    }),
    ["h2", "heading2", "subheading"]
  ),
  // Command for creating a level 3 heading
  new x(
    "Heading 3",
    (o) => I(o, {
      type: "heading",
      props: { level: "3" }
    }),
    ["h3", "heading3", "subheading"]
  ),
  // Command for creating an ordered list
  new x(
    "Numbered List",
    (o) => I(o, {
      type: "numberedListItem"
    }),
    ["li", "list", "numberedlist", "numbered list"]
  ),
  // Command for creating a bullet list
  new x(
    "Bullet List",
    (o) => I(o, {
      type: "bulletListItem"
    }),
    ["ul", "list", "bulletlist", "bullet list"]
  ),
  // Command for creating a paragraph (pretty useless)
  new x(
    "Paragraph",
    (o) => I(o, {
      type: "paragraph"
    }),
    ["p"]
  )
  //     replaceRangeWithNode(editor, range, node);
  //     return true;
  //   },
  //   ["ol", "orderedlist"],
  //   OrderedListIcon,
  //   "Used to display an ordered (enumerated) list item"
  // ),
  // Command for creating a blockquote
  // blockquote: new SlashCommand(
  //   "Block Quote",
  //   CommandGroup.BASIC_BLOCKS,
  //   (editor, range) => {
  //     const paragraph = editor.schema.node("paragraph");
  //     const node = editor.schema.node(
  //       "blockquote",
  //       { "block-id": uniqueId.generate() },
  //       paragraph
  //     );
  //     replaceRangeWithNode(editor, range, node);
  //     return true;
  //   },
  //   ["quote", "blockquote"],
  //   QuoteIcon,
  //   "Used to make a quote stand out",
  //   "Ctrl+Shift+B"
  // ),
  // Command for creating a horizontal rule
  // horizontalRule: new SlashCommand(
  //   "Horizontal Rule",
  //   CommandGroup.BASIC_BLOCKS,
  //   (editor, range) => {
  //     const node = editor.schema.node("horizontalRule", {
  //       "block-id": uniqueId.generate(),
  //     });
  //     // insert horizontal rule, create a new block after the horizontal rule if applicable
  //     // and put the cursor in the block after the horizontal rule.
  //     editor
  //       .chain()
  //       .focus()
  //       .replaceRangeAndUpdateSelection(range, node)
  //       .command(({ tr, dispatch }) => {
  //         if (dispatch) {
  //           // the node immediately after the cursor
  //           const nodeAfter = tr.selection.$to.nodeAfter;
  //           // the position of the cursor
  //           const cursorPos = tr.selection.$to.pos;
  //           // check if there is no node after the cursor (end of document)
  //           if (!nodeAfter) {
  //             // create a new block of the default type (probably paragraph) after the cursor
  //             const { parent } = tr.selection.$to;
  //             const node = parent.type.contentMatch.defaultType?.create();
  //             if (node) {
  //               tr.insert(cursorPos, node);
  //             }
  //           }
  //           // try to put the cursor at the start of the node directly after the inserted horizontal rule
  //           tr.doc.nodesBetween(cursorPos, cursorPos + 1, (node, pos) => {
  //             if (node.type.name !== "horizontalRule") {
  //               tr.setSelection(TextSelection.create(tr.doc, pos));
  //             }
  //           });
  //         }
  //         return true;
  //       })
  //       .scrollIntoView()
  //       .run();
  //     return true;
  //   },
  //   ["hr", "horizontalrule"],
  //   SeparatorIcon,
  //   "Used to separate sections with a horizontal line"
  // ),
  // Command for creating a table
  // table: new SlashCommand(
  //   "Table",
  //   CommandGroup.BASIC_BLOCKS,
  //   (editor, range) => {
  //     editor.chain().focus().deleteRange(range).run();
  //     // TODO: add blockid, pending https://github.com/ueberdosis/tiptap/pull/1469
  //     editor
  //       .chain()
  //       .focus()
  //       .insertTable({ rows: 1, cols: 2, withHeaderRow: false })
  //       .scrollIntoView()
  //       .run();
  //     return true;
  //   },
  //   ["table", "database"],
  //   TableIcon,
  //   "Used to create a simple table"
  // ),
], oo = E.create({
  name: "textAlignment",
  addGlobalAttributes() {
    return [
      {
        // Attribute is applied to block content instead of container so that child blocks don't inherit the text
        // alignment styling.
        types: ["paragraph", "heading", "bulletListItem", "numberedListItem"],
        attributes: {
          textAlignment: {
            default: "left",
            parseHTML: (o) => o.getAttribute("data-text-alignment"),
            renderHTML: (o) => o.textAlignment !== "left" && {
              "data-text-alignment": o.textAlignment
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlignment: (o) => ({ state: t }) => {
        const e = [], r = g(
          t.doc,
          t.selection.from
        );
        if (r === void 0)
          return !1;
        let n = r.startPos;
        for (; n < t.selection.to; )
          t.doc.resolve(n).node().type.spec.group === "blockContent" ? (e.push(n - 1), n += t.doc.resolve(n).node().nodeSize - 1) : n += 1;
        for (const i of e)
          t.tr.setNodeAttribute(i, "textAlignment", o);
        return !0;
      }
    };
  }
}), ro = E.create({
  name: "blockTextColor",
  addGlobalAttributes() {
    return [
      {
        types: ["blockContainer"],
        attributes: {
          textColor: {
            default: "default",
            parseHTML: (o) => o.hasAttribute("data-text-color") ? o.getAttribute("data-text-color") : "default",
            renderHTML: (o) => o.textColor !== "default" && {
              "data-text-color": o.textColor
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setBlockTextColor: (o, t) => ({ state: e, view: r }) => {
        const n = g(e.doc, o);
        return n === void 0 ? !1 : (e.tr.setNodeAttribute(n.startPos - 1, "textColor", t), r.focus(), !0);
      }
    };
  }
}), no = rt.create({
  name: "textColor",
  addAttributes() {
    return {
      color: {
        default: void 0,
        parseHTML: (o) => o.getAttribute("data-text-color"),
        renderHTML: (o) => ({
          "data-text-color": o.color
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (o) => typeof o == "string" ? !1 : o.hasAttribute("data-text-color") ? { color: o.getAttribute("data-text-color") } : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: o }) {
    return ["span", o, 0];
  },
  addCommands() {
    return {
      setTextColor: (o) => ({ commands: t }) => o !== "default" ? t.setMark(this.name, { color: o }) : t.unsetMark(this.name)
    };
  }
}), io = E.create({
  name: "trailingNode",
  addProseMirrorPlugins() {
    const o = new v(this.name);
    return [
      new C({
        key: o,
        appendTransaction: (t, e, r) => {
          const { doc: n, tr: i, schema: a } = r, s = o.getState(r), l = n.content.size - 2, d = a.nodes.blockContainer, c = a.nodes.paragraph;
          if (s)
            return i.insert(
              l,
              d.create(void 0, c.create())
            );
        },
        state: {
          init: (t, e) => {
          },
          apply: (t, e) => {
            if (!t.docChanged)
              return e;
            let r = t.doc.lastChild;
            if (!r || r.type.name !== "blockGroup")
              throw new Error("Expected blockGroup");
            if (r = r.lastChild, !r || r.type.name !== "blockContainer")
              throw new Error("Expected blockContainer");
            return r.nodeSize > 4;
          }
        }
      })
    ];
  }
}), so = (o) => {
  const t = [
    N.ClipboardTextSerializer,
    N.Commands,
    N.Editable,
    N.FocusEvents,
    N.Tabindex,
    // DevTools,
    Gt,
    // DropCursor,
    Ze.configure({
      emptyNodeClass: b.isEmpty,
      hasAnchorClass: b.hasAnchor,
      isFilterClass: b.isFilter,
      includeChildren: !0,
      showOnlyCurrent: !1
    }),
    Y.configure({
      types: ["blockContainer"]
    }),
    qt,
    // Comments,
    // basics:
    Kt,
    // marks:
    Ft,
    Rt,
    Wt,
    Yt,
    Vt,
    no,
    ro,
    fe,
    pe,
    oo,
    // custom blocks:
    ...Ae,
    $t.configure({ width: 5, color: "#ddeeff" }),
    // This needs to be at the bottom of this list, because Key events (such as enter, when selecting a /command),
    // should be handled before Enter handlers in other components like splitListItem
    io
  ];
  if (o.collaboration) {
    t.push(
      zt.configure({
        fragment: o.collaboration.fragment
      })
    );
    const e = (r) => {
      const n = document.createElement("span");
      n.classList.add(_["collaboration-cursor__caret"]), n.setAttribute("style", `border-color: ${r.color}`);
      const i = document.createElement("span");
      i.classList.add(_["collaboration-cursor__label"]), i.setAttribute("style", `background-color: ${r.color}`), i.insertBefore(document.createTextNode(r.name), null);
      const a = document.createTextNode("⁠"), s = document.createTextNode("⁠");
      return n.insertBefore(a, null), n.insertBefore(i, null), n.insertBefore(s, null), n;
    };
    t.push(
      Ut.configure({
        user: o.collaboration.user,
        render: o.collaboration.renderCursor || e,
        provider: o.collaboration.provider
      })
    );
  } else
    t.push(jt);
  return o.uiFactories.blockSideMenuFactory && t.push(
    qe.configure({
      editor: o.editor,
      blockSideMenuFactory: o.uiFactories.blockSideMenuFactory
    })
  ), o.uiFactories.formattingToolbarFactory && t.push(
    Ye.configure({
      editor: o.editor,
      formattingToolbarFactory: o.uiFactories.formattingToolbarFactory
    })
  ), o.uiFactories.hyperlinkToolbarFactory ? t.push(
    Xe.configure({
      hyperlinkToolbarFactory: o.uiFactories.hyperlinkToolbarFactory
    })
  ) : t.push(lt), o.uiFactories.slashMenuFactory && t.push(
    De.configure({
      editor: o.editor,
      commands: o.slashCommands,
      slashMenuFactory: o.uiFactories.slashMenuFactory
    })
  ), t;
}, ao = {
  enableInputRules: !0,
  enablePasteRules: !0,
  enableCoreExtensions: !1
};
class Fo {
  constructor(t = {}) {
    u(this, "_tiptapEditor");
    u(this, "blockCache", /* @__PURE__ */ new WeakMap());
    var n, i, a;
    this.options = t, t = {
      defaultStyles: !0,
      ...t
    };
    const e = so({
      editor: this,
      uiFactories: t.uiFactories || {},
      slashCommands: t.slashCommands || eo,
      collaboration: t.collaboration
    }), r = {
      // TODO: This approach to setting initial content is "cleaner" but requires the PM editor schema, which is only
      //  created after initializing the TipTap editor. Not sure it's feasible.
      // content:
      //   options.initialContent &&
      //   options.initialContent.map((block) =>
      //     blockToNode(block, this._tiptapEditor.schema).toJSON()
      //   ),
      ...ao,
      ...t._tiptapOptions,
      onCreate: () => {
        var s;
        (s = t.onEditorReady) == null || s.call(t, this), t.initialContent && this.replaceBlocks(this.topLevelBlocks, t.initialContent);
      },
      onUpdate: () => {
        var s;
        (s = t.onEditorContentChange) == null || s.call(t, this);
      },
      onSelectionUpdate: () => {
        var s;
        (s = t.onTextCursorPositionChange) == null || s.call(t, this);
      },
      editable: t.editable === void 0 ? !0 : t.editable,
      extensions: t.enableBlockNoteExtensions === !1 ? (n = t._tiptapOptions) == null ? void 0 : n.extensions : [...((i = t._tiptapOptions) == null ? void 0 : i.extensions) || [], ...e],
      editorProps: {
        attributes: {
          "data-theme": t.theme || "light",
          ...t.editorDOMAttributes || {},
          class: [
            _.bnEditor,
            _.bnRoot,
            t.defaultStyles ? _.defaultStyles : "",
            ((a = t.editorDOMAttributes) == null ? void 0 : a.class) || ""
          ].join(" ")
        }
      }
    };
    t.parentElement && (r.element = t.parentElement), this._tiptapEditor = new It(r);
  }
  get domElement() {
    return this._tiptapEditor.view.dom;
  }
  focus() {
    this._tiptapEditor.view.focus();
  }
  /**
   * Gets a snapshot of all top-level (non-nested) blocks in the editor.
   * @returns A snapshot of all top-level (non-nested) blocks in the editor.
   */
  get topLevelBlocks() {
    const t = [];
    return this._tiptapEditor.state.doc.firstChild.descendants((e) => (t.push(B(e, this.blockCache)), !1)), t;
  }
  /**
   * Gets a snapshot of an existing block from the editor.
   * @param blockIdentifier The identifier of an existing block that should be retrieved.
   * @returns The block that matches the identifier, or `undefined` if no matching block was found.
   */
  getBlock(t) {
    const e = typeof t == "string" ? t : t.id;
    let r;
    return this._tiptapEditor.state.doc.firstChild.descendants((n) => typeof r < "u" ? !1 : n.type.name !== "blockContainer" || n.attrs.id !== e ? !0 : (r = B(n, this.blockCache), !1)), r;
  }
  /**
   * Traverses all blocks in the editor depth-first, and executes a callback for each.
   * @param callback The callback to execute for each block. Returning `false` stops the traversal.
   * @param reverse Whether the blocks should be traversed in reverse order.
   */
  forEachBlock(t, e = !1) {
    const r = this.topLevelBlocks.slice();
    e && r.reverse();
    function n(i) {
      for (const a of i) {
        if (!t(a))
          return !1;
        const s = e ? a.children.slice().reverse() : a.children;
        if (!n(s))
          return !1;
      }
      return !0;
    }
    n(r);
  }
  /**
   * Gets a snapshot of the current text cursor position.
   * @returns A snapshot of the current text cursor position.
   */
  getTextCursorPosition() {
    const { node: t, depth: e, startPos: r, endPos: n } = g(
      this._tiptapEditor.state.doc,
      this._tiptapEditor.state.selection.from
    ), i = this._tiptapEditor.state.doc.resolve(n).index(e - 1), a = this._tiptapEditor.state.doc.resolve(n + 1).node().childCount;
    let s;
    i > 0 && (s = this._tiptapEditor.state.doc.resolve(r - 2).node());
    let l;
    return i < a - 1 && (l = this._tiptapEditor.state.doc.resolve(n + 2).node()), {
      block: B(t, this.blockCache),
      prevBlock: s === void 0 ? void 0 : B(s, this.blockCache),
      nextBlock: l === void 0 ? void 0 : B(l, this.blockCache)
    };
  }
  /**
   * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could
   * not be found.
   * @param targetBlock The identifier of an existing block that the text cursor should be moved to.
   * @param placement Whether the text cursor should be placed at the start or end of the block.
   */
  setTextCursorPosition(t, e = "start") {
    const r = typeof t == "string" ? t : t.id, { posBeforeNode: n } = K(r, this._tiptapEditor.state.doc), { startPos: i, contentNode: a } = g(
      this._tiptapEditor.state.doc,
      n + 2
    );
    e === "start" ? this._tiptapEditor.commands.setTextSelection(i + 1) : this._tiptapEditor.commands.setTextSelection(
      i + a.nodeSize - 1
    );
  }
  /**
   * Gets a snapshot of the current selection.
   */
  getSelection() {
    if (this._tiptapEditor.state.selection.from === this._tiptapEditor.state.selection.to)
      return;
    const t = [];
    return this._tiptapEditor.state.doc.descendants((e, r) => e.type.spec.group !== "blockContent" || r + e.nodeSize < this._tiptapEditor.state.selection.from || r > this._tiptapEditor.state.selection.to ? !0 : (t.push(
      B(
        this._tiptapEditor.state.doc.resolve(r).node(),
        this.blockCache
      )
    ), !1)), { blocks: t };
  }
  /**
   * Checks if the editor is currently editable, or if it's locked.
   * @returns True if the editor is editable, false otherwise.
   */
  get isEditable() {
    return this._tiptapEditor.isEditable;
  }
  /**
   * Makes the editor editable or locks it, depending on the argument passed.
   * @param editable True to make the editor editable, or false to lock it.
   */
  set isEditable(t) {
    this._tiptapEditor.setEditable(t);
  }
  /**
   * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an
   * error if the reference block could not be found.
   * @param blocksToInsert An array of partial blocks that should be inserted.
   * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.
   * @param placement Whether the blocks should be inserted just before, just after, or nested inside the
   * `referenceBlock`. Inserts the blocks at the start of the existing block's children if "nested" is used.
   */
  insertBlocks(t, e, r = "before") {
    pt(t, e, r, this._tiptapEditor);
  }
  /**
   * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be
   * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could
   * not be found.
   * @param blockToUpdate The block that should be updated.
   * @param update A partial block which defines how the existing block should be changed.
   */
  updateBlock(t, e) {
    re(t, e, this._tiptapEditor);
  }
  /**
   * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.
   * @param blocksToRemove An array of identifiers for existing blocks that should be removed.
   */
  removeBlocks(t) {
    ft(t, this._tiptapEditor);
  }
  /**
   * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or
   * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in
   * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.
   * @param blocksToRemove An array of blocks that should be replaced.
   * @param blocksToInsert An array of partial blocks to replace the old ones with.
   */
  replaceBlocks(t, e) {
    ne(t, e, this._tiptapEditor);
  }
  /**
   * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.
   */
  getActiveStyles() {
    const t = {}, e = this._tiptapEditor.state.selection.$to.marks(), r = /* @__PURE__ */ new Set([
      "bold",
      "italic",
      "underline",
      "strike",
      "code"
    ]), n = /* @__PURE__ */ new Set(["textColor", "backgroundColor"]);
    for (const i of e)
      r.has(i.type.name) ? t[i.type.name] = !0 : n.has(i.type.name) && (t[i.type.name] = i.attrs.color);
    return t;
  }
  /**
   * Adds styles to the currently selected content.
   * @param styles The styles to add.
   */
  addStyles(t) {
    const e = /* @__PURE__ */ new Set([
      "bold",
      "italic",
      "underline",
      "strike",
      "code"
    ]), r = /* @__PURE__ */ new Set(["textColor", "backgroundColor"]);
    for (const [n, i] of Object.entries(t))
      e.has(n) ? this._tiptapEditor.commands.setMark(n) : r.has(n) && this._tiptapEditor.commands.setMark(n, { color: i });
  }
  /**
   * Removes styles from the currently selected content.
   * @param styles The styles to remove.
   */
  removeStyles(t) {
    for (const e of Object.keys(t))
      this._tiptapEditor.commands.unsetMark(e);
  }
  /**
   * Toggles styles on the currently selected content.
   * @param styles The styles to toggle.
   */
  toggleStyles(t) {
    const e = /* @__PURE__ */ new Set([
      "bold",
      "italic",
      "underline",
      "strike",
      "code"
    ]), r = /* @__PURE__ */ new Set(["textColor", "backgroundColor"]);
    for (const [n, i] of Object.entries(t))
      e.has(n) ? this._tiptapEditor.commands.toggleMark(n) : r.has(n) && this._tiptapEditor.commands.toggleMark(n, { color: i });
  }
  /**
   * Gets the currently selected text.
   */
  getSelectedText() {
    return this._tiptapEditor.state.doc.textBetween(
      this._tiptapEditor.state.selection.from,
      this._tiptapEditor.state.selection.to
    );
  }
  /**
   * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.
   */
  getSelectedLinkUrl() {
    return this._tiptapEditor.getAttributes("link").href;
  }
  /**
   * Creates a new link to replace the selected content.
   * @param url The link URL.
   * @param text The text to display the link with.
   */
  createLink(t, e) {
    if (t === "")
      return;
    let { from: r, to: n } = this._tiptapEditor.state.selection;
    e || (e = this._tiptapEditor.state.doc.textBetween(r, n));
    const i = this._tiptapEditor.schema.mark("link", { href: t });
    this._tiptapEditor.view.dispatch(
      this._tiptapEditor.view.state.tr.insertText(e, r, n).addMark(r, r + e.length, i)
    );
  }
  /**
   * Checks if the block containing the text cursor can be nested.
   */
  canNestBlock() {
    const { startPos: t, depth: e } = g(
      this._tiptapEditor.state.doc,
      this._tiptapEditor.state.selection.from
    );
    return this._tiptapEditor.state.doc.resolve(t).index(e - 1) > 0;
  }
  /**
   * Nests the block containing the text cursor into the block above it.
   */
  nestBlock() {
    this._tiptapEditor.commands.sinkListItem("blockContainer");
  }
  /**
   * Checks if the block containing the text cursor is nested.
   */
  canUnnestBlock() {
    const { depth: t } = g(
      this._tiptapEditor.state.doc,
      this._tiptapEditor.state.selection.from
    );
    return t > 2;
  }
  /**
   * Lifts the block containing the text cursor out of its parent.
   */
  unnestBlock() {
    this._tiptapEditor.commands.liftListItem("blockContainer");
  }
  /**
   * Serializes blocks into an HTML string. To better conform to HTML standards, children of blocks which aren't list
   * items are un-nested in the output HTML.
   * @param blocks An array of blocks that should be serialized into HTML.
   * @returns The blocks, serialized as an HTML string.
   */
  async blocksToHTML(t) {
    return mt(t, this._tiptapEditor.schema);
  }
  /**
   * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and
   * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote
   * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.
   * @param html The HTML string to parse blocks from.
   * @returns The blocks parsed from the HTML string.
   */
  async HTMLToBlocks(t) {
    return gt(t, this._tiptapEditor.schema);
  }
  /**
   * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of
   * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.
   * @param blocks An array of blocks that should be serialized into Markdown.
   * @returns The blocks, serialized as a Markdown string.
   */
  async blocksToMarkdown(t) {
    return ae(t, this._tiptapEditor.schema);
  }
  /**
   * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on
   * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it
   * as text.
   * @param markdown The Markdown string to parse blocks from.
   * @returns The blocks parsed from the Markdown string.
   */
  async markdownToBlocks(t) {
    return le(t, this._tiptapEditor.schema);
  }
  /**
   * Updates the user info for the current user that's shown to other collaborators.
   */
  updateCollaborationUserInfo(t) {
    if (!this.options.collaboration)
      throw new Error(
        "Cannot update collaboration user info when collaboration is disabled."
      );
    this._tiptapEditor.commands.updateUser(t);
  }
}
export {
  x as BaseSlashMenuItem,
  Fo as BlockNoteEditor,
  tt as blockProps,
  eo as defaultSlashMenuItems,
  so as getBlockNoteExtensions,
  O as globalProps
};
//# sourceMappingURL=blocknote.js.map
