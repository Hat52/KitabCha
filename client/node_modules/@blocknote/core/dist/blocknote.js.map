{"version":3,"file":"blocknote.js","sources":["../src/extensions/Blocks/api/blockTypes.ts","../src/extensions/Blocks/helpers/getBlockInfoFromPos.ts","../src/extensions/UniqueID/UniqueID.ts","../src/shared/utils.ts","../src/api/nodeConversions/nodeConversions.ts","../src/api/util/nodeUtil.ts","../src/api/blockManipulation/blockManipulation.ts","../src/api/formatConversions/removeUnderlinesRehypePlugin.ts","../src/api/formatConversions/simplifyBlocksRehypePlugin.ts","../src/api/formatConversions/formatConversions.ts","../src/extensions/BackgroundColor/BackgroundColorExtension.ts","../src/extensions/BackgroundColor/BackgroundColorMark.ts","../src/extensions/Blocks/PreviousBlockTypePlugin.ts","../src/extensions/Blocks/nodes/BlockAttributes.ts","../src/extensions/Blocks/nodes/BlockContainer.ts","../src/extensions/Blocks/nodes/BlockGroup.ts","../src/extensions/Blocks/nodes/BlockContent/ParagraphBlockContent/ParagraphBlockContent.ts","../src/extensions/Blocks/nodes/BlockContent/HeadingBlockContent/HeadingBlockContent.ts","../src/extensions/Blocks/nodes/BlockContent/ListItemBlockContent/ListItemKeyboardShortcuts.ts","../src/extensions/Blocks/nodes/BlockContent/ListItemBlockContent/BulletListItemBlockContent/BulletListItemBlockContent.ts","../src/extensions/Blocks/nodes/BlockContent/ListItemBlockContent/NumberedListItemBlockContent/NumberedListIndexingPlugin.ts","../src/extensions/Blocks/nodes/BlockContent/ListItemBlockContent/NumberedListItemBlockContent/NumberedListItemBlockContent.ts","../src/extensions/Blocks/index.ts","../src/extensions/Blocks/helpers/findBlock.ts","../src/shared/plugins/suggestion/SuggestionPlugin.ts","../src/extensions/SlashMenu/SlashMenuExtension.ts","../src/extensions/DraggableBlocks/MultipleNodeSelection.ts","../src/extensions/DraggableBlocks/DraggableBlocksPlugin.ts","../src/extensions/DraggableBlocks/DraggableBlocksExtension.ts","../src/extensions/FormattingToolbar/FormattingToolbarPlugin.ts","../src/extensions/FormattingToolbar/FormattingToolbarExtension.ts","../src/extensions/HyperlinkToolbar/HyperlinkToolbarPlugin.ts","../src/extensions/HyperlinkToolbar/HyperlinkMark.ts","../src/extensions/Placeholder/PlaceholderExtension.ts","../src/shared/plugins/suggestion/SuggestionItem.ts","../src/extensions/SlashMenu/BaseSlashMenuItem.ts","../src/extensions/SlashMenu/defaultSlashMenuItems.tsx","../src/extensions/TextAlignment/TextAlignmentExtension.ts","../src/extensions/TextColor/TextColorExtension.ts","../src/extensions/TextColor/TextColorMark.ts","../src/extensions/TrailingNode/TrailingNodeExtension.ts","../src/BlockNoteExtensions.ts","../src/BlockNoteEditor.ts"],"sourcesContent":["/** Define the main block types **/\n\nimport { InlineContent, PartialInlineContent } from \"./inlineContentTypes\";\n\nexport type BlockTemplate<\n  // Type of the block.\n  // Examples might include: \"paragraph\", \"heading\", or \"bulletListItem\".\n  Type extends string,\n  // Changeable props which affect the block's behaviour or appearance.\n  // An example might be: { textAlignment: \"left\" | \"right\" | \"center\" } for a paragraph block.\n  Props extends Record<string, string>\n> = {\n  id: string;\n  type: Type;\n  props: Props;\n  content: InlineContent[];\n  children: Block[];\n};\n\nexport type DefaultBlockProps = {\n  backgroundColor: string;\n  textColor: string;\n  textAlignment: \"left\" | \"center\" | \"right\" | \"justify\";\n};\n\nexport type NumberedListItemBlock = BlockTemplate<\n  \"numberedListItem\",\n  DefaultBlockProps\n>;\n\nexport type BulletListItemBlock = BlockTemplate<\n  \"bulletListItem\",\n  DefaultBlockProps\n>;\n\nexport type HeadingBlock = BlockTemplate<\n  \"heading\",\n  DefaultBlockProps & {\n    level: \"1\" | \"2\" | \"3\";\n  }\n>;\n\nexport type ParagraphBlock = BlockTemplate<\"paragraph\", DefaultBlockProps>;\n\nexport type Block =\n  | ParagraphBlock\n  | HeadingBlock\n  | BulletListItemBlock\n  | NumberedListItemBlock;\n\nexport type BlockIdentifier = string | Block;\n\n/** Define \"Partial Blocks\", these are for updating or creating blocks */\nexport type PartialBlockTemplate<B extends Block> = B extends Block\n  ? Partial<Omit<B, \"props\" | \"children\" | \"content\" | \"type\">> & {\n      type?: B[\"type\"];\n      props?: Partial<B[\"props\"]>;\n      content?: string | PartialInlineContent[];\n      children?: PartialBlock[];\n    }\n  : never;\n\nexport type PartialBlock = PartialBlockTemplate<Block>;\n\nexport type BlockPropsTemplate<Props> = Props extends Block[\"props\"]\n  ? keyof Props\n  : never;\n\n/**\n * Expose blockProps. This is currently not very nice, but it's expected this\n * will change anyway once we allow for custom blocks\n */\n\nexport const globalProps: Array<keyof DefaultBlockProps> = [\n  \"backgroundColor\",\n  \"textColor\",\n  \"textAlignment\",\n];\n\nexport const blockProps: Record<Block[\"type\"], Set<string>> = {\n  paragraph: new Set<keyof ParagraphBlock[\"props\"]>([...globalProps]),\n  heading: new Set<keyof HeadingBlock[\"props\"]>([\n    ...globalProps,\n    \"level\" as const,\n  ]),\n  numberedListItem: new Set<keyof NumberedListItemBlock[\"props\"]>([\n    ...globalProps,\n  ]),\n  bulletListItem: new Set<keyof BulletListItemBlock[\"props\"]>([...globalProps]),\n};\n","import { Node, NodeType } from \"prosemirror-model\";\n\nexport type BlockInfo = {\n  id: string;\n  node: Node;\n  contentNode: Node;\n  contentType: NodeType;\n  numChildBlocks: number;\n  startPos: number;\n  endPos: number;\n  depth: number;\n};\n\n/**\n * Retrieves information regarding the most nested block node in a ProseMirror doc, that a given position lies in.\n * @param doc The ProseMirror doc.\n * @param posInBlock A position somewhere within a block node.\n * @returns A BlockInfo object for the block the given position is in, or undefined if the position is not in a block\n * for the given doc.\n */\nexport function getBlockInfoFromPos(\n  doc: Node,\n  posInBlock: number\n): BlockInfo | undefined {\n  if (posInBlock < 0 || posInBlock > doc.nodeSize) {\n    return undefined;\n  }\n\n  const $pos = doc.resolve(posInBlock);\n\n  const maxDepth = $pos.depth;\n  let node = $pos.node(maxDepth);\n  let depth = maxDepth;\n\n  while (true) {\n    if (depth < 0) {\n      return undefined;\n    }\n\n    if (node.type.name === \"blockContainer\") {\n      break;\n    }\n\n    depth -= 1;\n    node = $pos.node(depth);\n  }\n\n  const id = node.attrs[\"id\"];\n  const contentNode = node.firstChild!;\n  const contentType = contentNode.type;\n  const numChildBlocks = node.childCount === 2 ? node.lastChild!.childCount : 0;\n\n  const startPos = $pos.start(depth);\n  const endPos = $pos.end(depth);\n\n  return {\n    id,\n    node,\n    contentNode,\n    contentType,\n    numChildBlocks,\n    startPos,\n    endPos,\n    depth,\n  };\n}\n","import {\n  combineTransactionSteps,\n  Extension,\n  findChildren,\n  findChildrenInRange,\n  getChangedRanges,\n} from \"@tiptap/core\";\nimport { Fragment, Slice } from \"prosemirror-model\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\nimport { v4 } from \"uuid\";\n\n/**\n * Code from Tiptap UniqueID extension (https://tiptap.dev/api/extensions/unique-id)\n * This extension is licensed under MIT (even though it's part of Tiptap pro).\n *\n * If you're a user of BlockNote, we still recommend to support their awesome work and become a sponsor!\n * https://tiptap.dev/pro\n */\n\n/**\n * Removes duplicated values within an array.\n * Supports numbers, strings and objects.\n */\nfunction removeDuplicates(array: any, by = JSON.stringify) {\n  const seen: any = {};\n  return array.filter((item: any) => {\n    const key = by(item);\n    return Object.prototype.hasOwnProperty.call(seen, key)\n      ? false\n      : (seen[key] = true);\n  });\n}\n\n/**\n * Returns a list of duplicated items within an array.\n */\nfunction findDuplicates(items: any) {\n  const filtered = items.filter(\n    (el: any, index: number) => items.indexOf(el) !== index\n  );\n  const duplicates = removeDuplicates(filtered);\n  return duplicates;\n}\n\nconst UniqueID = Extension.create({\n  name: \"uniqueID\",\n  // we’ll set a very high priority to make sure this runs first\n  // and is compatible with `appendTransaction` hooks of other extensions\n  priority: 10000,\n  addOptions() {\n    return {\n      attributeName: \"id\",\n      types: [],\n      generateID: () => {\n        // Use mock ID if tests are running.\n        if ((window as any).__TEST_OPTIONS) {\n          if ((window as any).__TEST_OPTIONS.mockID === undefined) {\n            (window as any).__TEST_OPTIONS.mockID = 0;\n          } else {\n            (window as any).__TEST_OPTIONS.mockID++;\n          }\n\n          return (window as any).__TEST_OPTIONS.mockID.toString() as string;\n        }\n\n        return v4();\n      },\n      filterTransaction: null,\n    };\n  },\n  addGlobalAttributes() {\n    return [\n      {\n        types: this.options.types,\n        attributes: {\n          [this.options.attributeName]: {\n            default: null,\n            parseHTML: (element) =>\n              element.getAttribute(`data-${this.options.attributeName}`),\n            renderHTML: (attributes) => ({\n              [`data-${this.options.attributeName}`]:\n                attributes[this.options.attributeName],\n            }),\n          },\n        },\n      },\n    ];\n  },\n  // check initial content for missing ids\n  onCreate() {\n    // Don’t do this when the collaboration extension is active\n    // because this may update the content, so Y.js tries to merge these changes.\n    // This leads to empty block nodes.\n    // See: https://github.com/ueberdosis/tiptap/issues/2400\n    if (\n      this.editor.extensionManager.extensions.find(\n        (extension) => extension.name === \"collaboration\"\n      )\n    ) {\n      return;\n    }\n    const { view, state } = this.editor;\n    const { tr, doc } = state;\n    const { types, attributeName, generateID } = this.options;\n    const nodesWithoutId = findChildren(doc, (node) => {\n      return (\n        types.includes(node.type.name) && node.attrs[attributeName] === null\n      );\n    });\n    nodesWithoutId.forEach(({ node, pos }) => {\n      tr.setNodeMarkup(pos, undefined, {\n        ...node.attrs,\n        [attributeName]: generateID(),\n      });\n    });\n    tr.setMeta(\"addToHistory\", false);\n    view.dispatch(tr);\n  },\n  addProseMirrorPlugins() {\n    let dragSourceElement: any = null;\n    let transformPasted = false;\n    return [\n      new Plugin({\n        key: new PluginKey(\"uniqueID\"),\n        appendTransaction: (transactions, oldState, newState) => {\n          // console.log(\"appendTransaction\");\n          const docChanges =\n            transactions.some((transaction) => transaction.docChanged) &&\n            !oldState.doc.eq(newState.doc);\n          const filterTransactions =\n            this.options.filterTransaction &&\n            transactions.some((tr) => {\n              var _a, _b;\n              return !((_b = (_a = this.options).filterTransaction) === null ||\n              _b === void 0\n                ? void 0\n                : _b.call(_a, tr));\n            });\n          if (!docChanges || filterTransactions) {\n            return;\n          }\n          const { tr } = newState;\n          const { types, attributeName, generateID } = this.options;\n          const transform = combineTransactionSteps(\n            oldState.doc,\n            transactions as any\n          );\n          const { mapping } = transform;\n          // get changed ranges based on the old state\n          const changes = getChangedRanges(transform);\n\n          changes.forEach(({ newRange }) => {\n            const newNodes = findChildrenInRange(\n              newState.doc,\n              newRange,\n              (node) => {\n                return types.includes(node.type.name);\n              }\n            );\n            const newIds = newNodes\n              .map(({ node }) => node.attrs[attributeName])\n              .filter((id) => id !== null);\n            const duplicatedNewIds = findDuplicates(newIds);\n            newNodes.forEach(({ node, pos }) => {\n              var _a;\n              // instead of checking `node.attrs[attributeName]` directly\n              // we look at the current state of the node within `tr.doc`.\n              // this helps to prevent adding new ids to the same node\n              // if the node changed multiple times within one transaction\n              const id =\n                (_a = tr.doc.nodeAt(pos)) === null || _a === void 0\n                  ? void 0\n                  : _a.attrs[attributeName];\n              if (id === null) {\n                tr.setNodeMarkup(pos, undefined, {\n                  ...node.attrs,\n                  [attributeName]: generateID(),\n                });\n                return;\n              }\n              // check if the node doesn’t exist in the old state\n              const { deleted } = mapping.invert().mapResult(pos);\n              const newNode = deleted && duplicatedNewIds.includes(id);\n              if (newNode) {\n                tr.setNodeMarkup(pos, undefined, {\n                  ...node.attrs,\n                  [attributeName]: generateID(),\n                });\n              }\n            });\n          });\n          if (!tr.steps.length) {\n            return;\n          }\n          return tr;\n        },\n        // we register a global drag handler to track the current drag source element\n        view(view) {\n          const handleDragstart = (event: any) => {\n            var _a;\n            dragSourceElement = (\n              (_a = view.dom.parentElement) === null || _a === void 0\n                ? void 0\n                : _a.contains(event.target)\n            )\n              ? view.dom.parentElement\n              : null;\n          };\n          window.addEventListener(\"dragstart\", handleDragstart);\n          return {\n            destroy() {\n              window.removeEventListener(\"dragstart\", handleDragstart);\n            },\n          };\n        },\n        props: {\n          // `handleDOMEvents` is called before `transformPasted`\n          // so we can do some checks before\n          handleDOMEvents: {\n            // only create new ids for dropped content while holding `alt`\n            // or content is dragged from another editor\n            drop: (view, event: any) => {\n              var _a;\n              if (\n                dragSourceElement !== view.dom.parentElement ||\n                ((_a = event.dataTransfer) === null || _a === void 0\n                  ? void 0\n                  : _a.effectAllowed) === \"copy\"\n              ) {\n                dragSourceElement = null;\n                transformPasted = true;\n              }\n              return false;\n            },\n            // always create new ids on pasted content\n            paste: () => {\n              transformPasted = true;\n              return false;\n            },\n          },\n          // we’ll remove ids for every pasted node\n          // so we can create a new one within `appendTransaction`\n          transformPasted: (slice) => {\n            if (!transformPasted) {\n              return slice;\n            }\n            const { types, attributeName } = this.options;\n            const removeId = (fragment: any) => {\n              const list: any[] = [];\n              fragment.forEach((node: any) => {\n                // don’t touch text nodes\n                if (node.isText) {\n                  list.push(node);\n                  return;\n                }\n                // check for any other child nodes\n                if (!types.includes(node.type.name)) {\n                  list.push(node.copy(removeId(node.content)));\n                  return;\n                }\n                // remove id\n                const nodeWithoutId = node.type.create(\n                  {\n                    ...node.attrs,\n                    [attributeName]: null,\n                  },\n                  removeId(node.content),\n                  node.marks\n                );\n                list.push(nodeWithoutId);\n              });\n              return Fragment.from(list);\n            };\n            // reset check\n            transformPasted = false;\n            return new Slice(\n              removeId(slice.content),\n              slice.openStart,\n              slice.openEnd\n            );\n          },\n        },\n      }),\n    ];\n  },\n});\n\nexport { UniqueID, UniqueID as default };\n//# sourceMappingURL=tiptap-extension-unique-id.esm.js.map\n","export const isAppleOS = () =>\n  /Mac/.test(navigator.platform) ||\n  (/AppleWebKit/.test(navigator.userAgent) &&\n    /Mobile\\/\\w+/.test(navigator.userAgent));\n\nexport function formatKeyboardShortcut(shortcut: string) {\n  if (isAppleOS()) {\n    return shortcut.replace(\"Mod\", \"⌘\");\n  } else {\n    return shortcut.replace(\"Mod\", \"Ctrl\");\n  }\n}\n\nexport class UnreachableCaseError extends Error {\n  constructor(val: never) {\n    super(`Unreachable case: ${val}`);\n  }\n}\n","import { Mark } from \"@tiptap/pm/model\";\nimport { Node, Schema } from \"prosemirror-model\";\nimport {\n  Block,\n  blockProps,\n  PartialBlock,\n} from \"../../extensions/Blocks/api/blockTypes\";\nimport {\n  ColorStyle,\n  InlineContent,\n  Link,\n  PartialInlineContent,\n  PartialLink,\n  StyledText,\n  Styles,\n  ToggledStyle,\n} from \"../../extensions/Blocks/api/inlineContentTypes\";\nimport { getBlockInfoFromPos } from \"../../extensions/Blocks/helpers/getBlockInfoFromPos\";\nimport UniqueID from \"../../extensions/UniqueID/UniqueID\";\nimport { UnreachableCaseError } from \"../../shared/utils\";\n\nconst toggleStyles = new Set<ToggledStyle>([\n  \"bold\",\n  \"italic\",\n  \"underline\",\n  \"strike\",\n  \"code\",\n]);\nconst colorStyles = new Set<ColorStyle>([\"textColor\", \"backgroundColor\"]);\n\n/**\n * Convert a StyledText inline element to a\n * prosemirror text node with the appropriate marks\n */\nfunction styledTextToNode(styledText: StyledText, schema: Schema): Node {\n  const marks: Mark[] = [];\n\n  for (const [style, value] of Object.entries(styledText.styles)) {\n    if (toggleStyles.has(style as ToggledStyle)) {\n      marks.push(schema.mark(style));\n    } else if (colorStyles.has(style as ColorStyle)) {\n      marks.push(schema.mark(style, { color: value }));\n    }\n  }\n\n  return schema.text(styledText.text, marks);\n}\n\n/**\n * Converts a Link inline content element to\n * prosemirror text nodes with the appropriate marks\n */\nfunction linkToNodes(link: PartialLink, schema: Schema): Node[] {\n  const linkMark = schema.marks.link.create({\n    href: link.href,\n  });\n\n  return styledTextArrayToNodes(link.content, schema).map((node) => {\n    return node.mark([...node.marks, linkMark]);\n  });\n}\n\n/**\n * Converts an array of StyledText inline content elements to\n * prosemirror text nodes with the appropriate marks\n */\nfunction styledTextArrayToNodes(\n  content: string | StyledText[],\n  schema: Schema\n): Node[] {\n  let nodes: Node[] = [];\n\n  if (typeof content === \"string\") {\n    nodes.push(schema.text(content));\n    return nodes;\n  }\n\n  for (const styledText of content) {\n    nodes.push(styledTextToNode(styledText, schema));\n  }\n  return nodes;\n}\n\n/**\n * converts an array of inline content elements to prosemirror nodes\n */\nexport function inlineContentToNodes(\n  blockContent: PartialInlineContent[],\n  schema: Schema\n): Node[] {\n  let nodes: Node[] = [];\n\n  for (const content of blockContent) {\n    if (content.type === \"link\") {\n      nodes.push(...linkToNodes(content, schema));\n    } else if (content.type === \"text\") {\n      nodes.push(...styledTextArrayToNodes([content], schema));\n    } else {\n      throw new UnreachableCaseError(content);\n    }\n  }\n  return nodes;\n}\n\n/**\n * Converts a BlockNote block to a TipTap node.\n */\nexport function blockToNode(block: PartialBlock, schema: Schema) {\n  let id = block.id;\n\n  if (id === undefined) {\n    id = UniqueID.options.generateID();\n  }\n\n  let type = block.type;\n\n  if (type === undefined) {\n    type = \"paragraph\";\n  }\n\n  let contentNode: Node;\n\n  if (!block.content) {\n    contentNode = schema.nodes[type].create(block.props);\n  } else if (typeof block.content === \"string\") {\n    contentNode = schema.nodes[type].create(\n      block.props,\n      schema.text(block.content)\n    );\n  } else {\n    const nodes = inlineContentToNodes(block.content, schema);\n    contentNode = schema.nodes[type].create(block.props, nodes);\n  }\n\n  const children: Node[] = [];\n\n  if (block.children) {\n    for (const child of block.children) {\n      children.push(blockToNode(child, schema));\n    }\n  }\n\n  const groupNode = schema.nodes[\"blockGroup\"].create({}, children);\n\n  return schema.nodes[\"blockContainer\"].create(\n    {\n      id: id,\n      ...block.props,\n    },\n    children.length > 0 ? [contentNode, groupNode] : contentNode\n  );\n}\n\n/**\n * Converts an internal (prosemirror) content node to a BlockNote InlineContent array.\n */\nfunction contentNodeToInlineContent(contentNode: Node) {\n  const content: InlineContent[] = [];\n\n  let currentLink: Link | undefined = undefined;\n\n  // Most of the logic below is for handling links because in ProseMirror links are marks\n  // while in BlockNote links are a type of inline content\n  contentNode.content.forEach((node) => {\n    const styles: Styles = {};\n\n    let linkMark: Mark | undefined;\n    for (const mark of node.marks) {\n      if (mark.type.name === \"link\") {\n        linkMark = mark;\n      } else if (toggleStyles.has(mark.type.name as ToggledStyle)) {\n        styles[mark.type.name as ToggledStyle] = true;\n      } else if (colorStyles.has(mark.type.name as ColorStyle)) {\n        styles[mark.type.name as ColorStyle] = mark.attrs.color;\n      } else {\n        throw Error(\"Mark is of an unrecognized type: \" + mark.type.name);\n      }\n    }\n\n    if (linkMark && currentLink && linkMark.attrs.href === currentLink.href) {\n      // if the node is a link that matches the current link, add it to the current link\n      currentLink.content.push({\n        type: \"text\",\n        text: node.textContent,\n        styles,\n      });\n    } else if (linkMark) {\n      // if the node is a link that doesn't match the current link, create a new link\n      currentLink = {\n        type: \"link\",\n        href: linkMark.attrs.href,\n        content: [\n          {\n            type: \"text\",\n            text: node.textContent,\n            styles,\n          },\n        ],\n      };\n      content.push(currentLink);\n    } else {\n      // if the node is not a link, add it to the content\n      content.push({\n        type: \"text\",\n        text: node.textContent,\n        styles,\n      });\n      currentLink = undefined;\n    }\n  });\n  return content;\n}\n\n/**\n * Convert a TipTap node to a BlockNote block.\n */\nexport function nodeToBlock(\n  node: Node,\n  blockCache?: WeakMap<Node, Block>\n): Block {\n  if (node.type.name !== \"blockContainer\") {\n    throw Error(\n      \"Node must be of type blockContainer, but is of type\" +\n        node.type.name +\n        \".\"\n    );\n  }\n\n  const cachedBlock = blockCache?.get(node);\n\n  if (cachedBlock) {\n    return cachedBlock;\n  }\n\n  const blockInfo = getBlockInfoFromPos(node, 0)!;\n\n  let id = blockInfo.id;\n\n  // Only used for blocks converted from other formats.\n  if (id === null) {\n    id = UniqueID.options.generateID();\n  }\n\n  const props: any = {};\n  for (const [attr, value] of Object.entries({\n    ...blockInfo.node.attrs,\n    ...blockInfo.contentNode.attrs,\n  })) {\n    if (!(blockInfo.contentType.name in blockProps)) {\n      throw Error(\n        \"Block is of an unrecognized type: \" + blockInfo.contentType.name\n      );\n    }\n\n    const validAttrs = blockProps[blockInfo.contentType.name as Block[\"type\"]];\n\n    if (validAttrs.has(attr)) {\n      props[attr] = value;\n    }\n  }\n\n  const content = contentNodeToInlineContent(blockInfo.contentNode);\n\n  const children: Block[] = [];\n  for (let i = 0; i < blockInfo.numChildBlocks; i++) {\n    children.push(nodeToBlock(blockInfo.node.lastChild!.child(i)));\n  }\n\n  const block: Block = {\n    id,\n    type: blockInfo.contentType.name as Block[\"type\"],\n    props,\n    content,\n    children,\n  };\n\n  blockCache?.set(node, block);\n\n  return block;\n}\n","import { Node } from \"prosemirror-model\";\n\n/**\n * Get a TipTap node by id\n */\nexport function getNodeById(\n  id: string,\n  doc: Node\n): { node: Node; posBeforeNode: number } {\n  let targetNode: Node | undefined = undefined;\n  let posBeforeNode: number | undefined = undefined;\n\n  doc.firstChild!.descendants((node, pos) => {\n    // Skips traversing nodes after node with target ID has been found.\n    if (targetNode) {\n      return false;\n    }\n\n    // Keeps traversing nodes if block with target ID has not been found.\n    if (node.type.name !== \"blockContainer\" || node.attrs.id !== id) {\n      return true;\n    }\n\n    targetNode = node;\n    posBeforeNode = pos + 1;\n\n    return false;\n  });\n\n  if (targetNode === undefined || posBeforeNode === undefined) {\n    throw Error(\"Could not find block in the editor with matching ID.\");\n  }\n\n  return {\n    node: targetNode,\n    posBeforeNode: posBeforeNode,\n  };\n}\n","import { Editor } from \"@tiptap/core\";\nimport { Node } from \"prosemirror-model\";\nimport {\n  BlockIdentifier,\n  PartialBlock,\n} from \"../../extensions/Blocks/api/blockTypes\";\nimport { blockToNode } from \"../nodeConversions/nodeConversions\";\nimport { getNodeById } from \"../util/nodeUtil\";\n\nexport function insertBlocks(\n  blocksToInsert: PartialBlock[],\n  referenceBlock: BlockIdentifier,\n  placement: \"before\" | \"after\" | \"nested\" = \"before\",\n  editor: Editor\n): void {\n  const id =\n    typeof referenceBlock === \"string\" ? referenceBlock : referenceBlock.id;\n\n  const nodesToInsert: Node[] = [];\n  for (const blockSpec of blocksToInsert) {\n    nodesToInsert.push(blockToNode(blockSpec, editor.schema));\n  }\n\n  let insertionPos = -1;\n\n  const { node, posBeforeNode } = getNodeById(id, editor.state.doc);\n\n  if (placement === \"before\") {\n    insertionPos = posBeforeNode;\n  }\n\n  if (placement === \"after\") {\n    insertionPos = posBeforeNode + node.nodeSize;\n  }\n\n  if (placement === \"nested\") {\n    // Case if block doesn't already have children.\n    if (node.childCount < 2) {\n      insertionPos = posBeforeNode + node.firstChild!.nodeSize + 1;\n\n      const blockGroupNode = editor.state.schema.nodes[\"blockGroup\"].create(\n        {},\n        nodesToInsert\n      );\n\n      editor.view.dispatch(\n        editor.state.tr.insert(insertionPos, blockGroupNode)\n      );\n\n      return;\n    }\n\n    insertionPos = posBeforeNode + node.firstChild!.nodeSize + 2;\n  }\n\n  editor.view.dispatch(editor.state.tr.insert(insertionPos, nodesToInsert));\n}\n\nexport function updateBlock(\n  blockToUpdate: BlockIdentifier,\n  update: PartialBlock,\n  editor: Editor\n) {\n  const id =\n    typeof blockToUpdate === \"string\" ? blockToUpdate : blockToUpdate.id;\n  const { posBeforeNode } = getNodeById(id, editor.state.doc);\n\n  editor.commands.BNUpdateBlock(posBeforeNode + 1, update);\n}\n\nexport function removeBlocks(\n  blocksToRemove: BlockIdentifier[],\n  editor: Editor\n) {\n  const idsOfBlocksToRemove = new Set<string>(\n    blocksToRemove.map((block) =>\n      typeof block === \"string\" ? block : block.id\n    )\n  );\n\n  let removedSize = 0;\n\n  editor.state.doc.descendants((node, pos) => {\n    // Skips traversing nodes after all target blocks have been removed.\n    if (idsOfBlocksToRemove.size === 0) {\n      return false;\n    }\n\n    // Keeps traversing nodes if block with target ID has not been found.\n    if (\n      node.type.name !== \"blockContainer\" ||\n      !idsOfBlocksToRemove.has(node.attrs.id)\n    ) {\n      return true;\n    }\n\n    idsOfBlocksToRemove.delete(node.attrs.id);\n    const oldDocSize = editor.state.doc.nodeSize;\n\n    editor.commands.BNDeleteBlock(pos - removedSize + 1);\n\n    const newDocSize = editor.state.doc.nodeSize;\n    removedSize += oldDocSize - newDocSize;\n\n    return false;\n  });\n\n  if (idsOfBlocksToRemove.size > 0) {\n    let notFoundIds = [...idsOfBlocksToRemove].join(\"\\n\");\n\n    throw Error(\n      \"Blocks with the following IDs could not be found in the editor: \" +\n        notFoundIds\n    );\n  }\n}\n\nexport function replaceBlocks(\n  blocksToRemove: BlockIdentifier[],\n  blocksToInsert: PartialBlock[],\n  editor: Editor\n) {\n  insertBlocks(blocksToInsert, blocksToRemove[0], \"before\", editor);\n  removeBlocks(blocksToRemove, editor);\n}\n","import { Element as HASTElement, Parent as HASTParent } from \"hast\";\n\n/**\n * Rehype plugin which removes <u> tags. Used to remove underlines before converting HTML to markdown, as Markdown\n * doesn't support underlines.\n */\nexport function removeUnderlines() {\n  const removeUnderlinesHelper = (tree: HASTParent) => {\n    let numChildElements = tree.children.length;\n\n    for (let i = 0; i < numChildElements; i++) {\n      const node = tree.children[i];\n\n      if (node.type === \"element\") {\n        // Recursively removes underlines from child elements.\n        removeUnderlinesHelper(node);\n\n        if ((node as HASTElement).tagName === \"u\") {\n          // Lifts child nodes outside underline element, deletes the underline element, and updates current index &\n          // the number of child elements.\n          if (node.children.length > 0) {\n            tree.children.splice(i, 1, ...node.children);\n\n            const numElementsAdded = node.children.length - 1;\n            numChildElements += numElementsAdded;\n            i += numElementsAdded;\n          } else {\n            tree.children.splice(i, 1);\n\n            numChildElements--;\n            i--;\n          }\n        }\n      }\n    }\n  };\n\n  return removeUnderlinesHelper;\n}\n","import { Element as HASTElement, Parent as HASTParent } from \"hast\";\nimport { fromDom } from \"hast-util-from-dom\";\n\ntype SimplifyBlocksOptions = {\n  orderedListItemBlockTypes: Set<string>;\n  unorderedListItemBlockTypes: Set<string>;\n};\n\n/**\n * Rehype plugin which converts the HTML output string rendered by BlockNote into a simplified structure which better\n * follows HTML standards. It does several things:\n * - Removes all block related div elements, leaving only the actual content inside the block.\n * - Lifts nested blocks to a higher level for all block types that don't represent list items.\n * - Wraps blocks which represent list items in corresponding ul/ol HTML elements and restructures them to comply\n * with HTML list structure.\n * @param options Options for specifying which block types represent ordered and unordered list items.\n */\nexport function simplifyBlocks(options: SimplifyBlocksOptions) {\n  const listItemBlockTypes = new Set<string>([\n    ...options.orderedListItemBlockTypes,\n    ...options.unorderedListItemBlockTypes,\n  ]);\n\n  const simplifyBlocksHelper = (tree: HASTParent) => {\n    let numChildElements = tree.children.length;\n    let activeList: HASTElement | undefined;\n\n    for (let i = 0; i < numChildElements; i++) {\n      const blockOuter = tree.children[i] as HASTElement;\n      const blockContainer = blockOuter.children[0] as HASTElement;\n      const blockContent = blockContainer.children[0] as HASTElement;\n      const blockGroup =\n        blockContainer.children.length === 2\n          ? (blockContainer.children[1] as HASTElement)\n          : null;\n\n      const isListItemBlock = listItemBlockTypes.has(\n        blockContent.properties![\"dataContentType\"] as string\n      );\n\n      const listItemBlockType = isListItemBlock\n        ? options.orderedListItemBlockTypes.has(\n            blockContent.properties![\"dataContentType\"] as string\n          )\n          ? \"ol\"\n          : \"ul\"\n        : null;\n\n      // Plugin runs recursively to process nested blocks.\n      if (blockGroup !== null) {\n        simplifyBlocksHelper(blockGroup);\n      }\n\n      // Checks that there is an active list, but the block can't be added to it as it's of a different type.\n      if (activeList && activeList.tagName !== listItemBlockType) {\n        // Blocks that were copied into the list are removed and the list is inserted in their place.\n        tree.children.splice(\n          i - activeList.children.length,\n          activeList.children.length,\n          activeList\n        );\n\n        // Updates the current index and number of child elements.\n        const numElementsRemoved = activeList.children.length - 1;\n        i -= numElementsRemoved;\n        numChildElements -= numElementsRemoved;\n\n        activeList = undefined;\n      }\n\n      // Checks if the block represents a list item.\n      if (isListItemBlock) {\n        // Checks if a list isn't already active. We don't have to check if the block and the list are of the same\n        // type as this was already done earlier.\n        if (!activeList) {\n          // Creates a new list element to represent an active list.\n          activeList = fromDom(\n            document.createElement(listItemBlockType!)\n          ) as HASTElement;\n        }\n\n        // Creates a new list item element to represent the block.\n        const listItemElement = fromDom(\n          document.createElement(\"li\")\n        ) as HASTElement;\n\n        // Adds only the content inside the block to the active list.\n        listItemElement.children.push(blockContent.children[0]);\n        // Nested blocks have already been processed in the recursive function call, so the resulting elements are\n        // also added to the active list.\n        if (blockGroup !== null) {\n          listItemElement.children.push(...blockGroup.children);\n        }\n\n        // Adds the list item representing the block to the active list.\n        activeList.children.push(listItemElement);\n      } else if (blockGroup !== null) {\n        // Lifts all children out of the current block, as only list items should allow nesting.\n        tree.children.splice(i + 1, 0, ...blockGroup.children);\n        // Replaces the block with only the content inside it.\n        tree.children[i] = blockContent.children[0];\n\n        // Updates the current index and number of child elements.\n        const numElementsAdded = blockGroup.children.length;\n        i += numElementsAdded;\n        numChildElements += numElementsAdded;\n      } else {\n        // Replaces the block with only the content inside it.\n        tree.children[i] = blockContent.children[0];\n      }\n    }\n\n    // Since the active list is only inserted after encountering a block which can't be added to it, there are cases\n    // where it remains un-inserted after processing all blocks, which are handled here.\n    if (activeList) {\n      tree.children.splice(\n        numChildElements - activeList.children.length,\n        activeList.children.length,\n        activeList\n      );\n    }\n  };\n\n  return simplifyBlocksHelper;\n}\n","import { DOMParser, DOMSerializer, Schema } from \"prosemirror-model\";\nimport rehypeParse from \"rehype-parse\";\nimport rehypeRemark from \"rehype-remark\";\nimport rehypeStringify from \"rehype-stringify\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkParse from \"remark-parse\";\nimport remarkRehype from \"remark-rehype\";\nimport remarkStringify from \"remark-stringify\";\nimport { unified } from \"unified\";\nimport { Block } from \"../../extensions/Blocks/api/blockTypes\";\nimport { blockToNode, nodeToBlock } from \"../nodeConversions/nodeConversions\";\nimport { removeUnderlines } from \"./removeUnderlinesRehypePlugin\";\nimport { simplifyBlocks } from \"./simplifyBlocksRehypePlugin\";\n\nexport async function blocksToHTML(\n  blocks: Block[],\n  schema: Schema\n): Promise<string> {\n  const htmlParentElement = document.createElement(\"div\");\n  const serializer = DOMSerializer.fromSchema(schema);\n\n  for (const block of blocks) {\n    const node = blockToNode(block, schema);\n    const htmlNode = serializer.serializeNode(node);\n    htmlParentElement.appendChild(htmlNode);\n  }\n\n  const htmlString = await unified()\n    .use(rehypeParse, { fragment: true })\n    .use(simplifyBlocks, {\n      orderedListItemBlockTypes: new Set<string>([\"numberedListItem\"]),\n      unorderedListItemBlockTypes: new Set<string>([\"bulletListItem\"]),\n    })\n    .use(rehypeStringify)\n    .process(htmlParentElement.innerHTML);\n\n  return htmlString.value as string;\n}\n\nexport async function HTMLToBlocks(\n  html: string,\n  schema: Schema\n): Promise<Block[]> {\n  const htmlNode = document.createElement(\"div\");\n  htmlNode.innerHTML = html.trim();\n\n  const parser = DOMParser.fromSchema(schema);\n  const parentNode = parser.parse(htmlNode);\n\n  const blocks: Block[] = [];\n\n  for (let i = 0; i < parentNode.firstChild!.childCount; i++) {\n    blocks.push(nodeToBlock(parentNode.firstChild!.child(i)));\n  }\n\n  return blocks;\n}\n\nexport async function blocksToMarkdown(\n  blocks: Block[],\n  schema: Schema\n): Promise<string> {\n  const markdownString = await unified()\n    .use(rehypeParse, { fragment: true })\n    .use(removeUnderlines)\n    .use(rehypeRemark)\n    .use(remarkGfm)\n    .use(remarkStringify)\n    .process(await blocksToHTML(blocks, schema));\n\n  return markdownString.value as string;\n}\n\nexport async function markdownToBlocks(\n  markdown: string,\n  schema: Schema\n): Promise<Block[]> {\n  const htmlString = await unified()\n    .use(remarkParse)\n    .use(remarkGfm)\n    .use(remarkRehype)\n    .use(rehypeStringify)\n    .process(markdown);\n\n  return HTMLToBlocks(htmlString.value as string, schema);\n}\n","import { Extension } from \"@tiptap/core\";\nimport { getBlockInfoFromPos } from \"../Blocks/helpers/getBlockInfoFromPos\";\n\ndeclare module \"@tiptap/core\" {\n  interface Commands<ReturnType> {\n    blockBackgroundColor: {\n      setBlockBackgroundColor: (\n        posInBlock: number,\n        color: string\n      ) => ReturnType;\n    };\n  }\n}\n\nexport const BackgroundColorExtension = Extension.create({\n  name: \"blockBackgroundColor\",\n\n  addGlobalAttributes() {\n    return [\n      {\n        types: [\"blockContainer\"],\n        attributes: {\n          backgroundColor: {\n            default: \"default\",\n            parseHTML: (element) =>\n              element.hasAttribute(\"data-background-color\")\n                ? element.getAttribute(\"data-background-color\")\n                : \"default\",\n            renderHTML: (attributes) =>\n              attributes.backgroundColor !== \"default\" && {\n                \"data-background-color\": attributes.backgroundColor,\n              },\n          },\n        },\n      },\n    ];\n  },\n\n  addCommands() {\n    return {\n      setBlockBackgroundColor:\n        (posInBlock, color) =>\n        ({ state, view }) => {\n          const blockInfo = getBlockInfoFromPos(state.doc, posInBlock);\n          if (blockInfo === undefined) {\n            return false;\n          }\n\n          state.tr.setNodeAttribute(\n            blockInfo.startPos - 1,\n            \"backgroundColor\",\n            color\n          );\n\n          view.focus();\n\n          return true;\n        },\n    };\n  },\n});\n","import { Mark } from \"@tiptap/core\";\n\ndeclare module \"@tiptap/core\" {\n  interface Commands<ReturnType> {\n    backgroundColor: {\n      setBackgroundColor: (color: string) => ReturnType;\n    };\n  }\n}\n\nexport const BackgroundColorMark = Mark.create({\n  name: \"backgroundColor\",\n\n  addAttributes() {\n    return {\n      color: {\n        default: undefined,\n        parseHTML: (element) => element.getAttribute(\"data-background-color\"),\n        renderHTML: (attributes) => ({\n          \"data-background-color\": attributes.color,\n        }),\n      },\n    };\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: \"span\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          if (element.hasAttribute(\"data-background-color\")) {\n            return { color: element.getAttribute(\"data-background-color\") };\n          }\n\n          return false;\n        },\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\"span\", HTMLAttributes, 0];\n  },\n\n  addCommands() {\n    return {\n      setBackgroundColor:\n        (color) =>\n        ({ commands }) => {\n          if (color !== \"default\") {\n            return commands.setMark(this.name, { color: color });\n          }\n\n          return commands.unsetMark(this.name);\n        },\n    };\n  },\n});\n","import { findChildren } from \"@tiptap/core\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\n\nconst PLUGIN_KEY = new PluginKey(`previous-blocks`);\n\nconst nodeAttributes: Record<string, string> = {\n  // Numbered List Items\n  index: \"index\",\n  // Headings\n  level: \"level\",\n  // All Blocks\n  type: \"type\",\n  depth: \"depth\",\n  \"depth-change\": \"depth-change\",\n};\n\n/**\n * This plugin tracks transformation of Block node attributes, so we can support CSS transitions.\n *\n * Problem it solves: ProseMirror recreates the DOM when transactions happen. So when a transaction changes a Node attribute,\n * it results in a completely new DOM element. This means CSS transitions don't work.\n *\n * Solution: When attributes change on a node, this plugin sets a data-* attribute with the \"previous\" value. This way we can still use CSS transitions. (See block.module.css)\n */\nexport const PreviousBlockTypePlugin = () => {\n  let timeout: any;\n  return new Plugin({\n    key: PLUGIN_KEY,\n    view(_editorView) {\n      return {\n        update: async (view, _prevState) => {\n          if (this.key?.getState(view.state).updatedBlocks.size > 0) {\n            // use setTimeout 0 to clear the decorations so that at least\n            // for one DOM-render the decorations have been applied\n            timeout = setTimeout(() => {\n              view.dispatch(\n                view.state.tr.setMeta(PLUGIN_KEY, { clearUpdate: true })\n              );\n            }, 0);\n          }\n        },\n        destroy: () => {\n          if (timeout) {\n            clearTimeout(timeout);\n          }\n        },\n      };\n    },\n    state: {\n      init() {\n        return {\n          // Block attributes, by block ID, from just before the previous transaction.\n          prevTransactionOldBlockAttrs: {} as any,\n          // Block attributes, by block ID, from just before the current transaction.\n          currentTransactionOldBlockAttrs: {} as any,\n          // Set of IDs of blocks whose attributes changed from the current transaction.\n          updatedBlocks: new Set<string>(),\n        };\n      },\n\n      apply(transaction, prev, oldState, newState) {\n        prev.currentTransactionOldBlockAttrs = {};\n        prev.updatedBlocks.clear();\n\n        if (!transaction.docChanged || oldState.doc.eq(newState.doc)) {\n          return prev;\n        }\n\n        // TODO: Instead of iterating through the entire document, only check nodes affected by the transactions. Will\n        //  also probably require checking nodes affected by the previous transaction too.\n        // We didn't get this to work yet:\n        // const transform = combineTransactionSteps(oldState.doc, [transaction]);\n        // // const { mapping } = transform;\n        // const changes = getChangedRanges(transform);\n        //\n        // changes.forEach(({ oldRange, newRange }) => {\n        // const oldNodes = findChildrenInRange(\n        //   oldState.doc,\n        //   oldRange,\n        //   (node) => node.attrs.id\n        // );\n        //\n        // const newNodes = findChildrenInRange(\n        //   newState.doc,\n        //   newRange,\n        //   (node) => node.attrs.id\n        // );\n\n        const currentTransactionOriginalOldBlockAttrs = {} as any;\n\n        const oldNodes = findChildren(oldState.doc, (node) => node.attrs.id);\n        const oldNodesById = new Map(\n          oldNodes.map((node) => [node.node.attrs.id, node])\n        );\n        const newNodes = findChildren(newState.doc, (node) => node.attrs.id);\n\n        // Traverses all block containers in the new editor state.\n        for (let node of newNodes) {\n          const oldNode = oldNodesById.get(node.node.attrs.id);\n\n          const oldContentNode = oldNode?.node.firstChild;\n          const newContentNode = node.node.firstChild;\n\n          if (oldNode && oldContentNode && newContentNode) {\n            const newAttrs = {\n              index: newContentNode.attrs.index,\n              level: newContentNode.attrs.level,\n              type: newContentNode.type.name,\n              depth: newState.doc.resolve(node.pos).depth,\n            };\n\n            let oldAttrs = {\n              index: oldContentNode.attrs.index,\n              level: oldContentNode.attrs.level,\n              type: oldContentNode.type.name,\n              depth: oldState.doc.resolve(oldNode.pos).depth,\n            };\n\n            currentTransactionOriginalOldBlockAttrs[node.node.attrs.id] =\n              oldAttrs;\n\n            // Whenever a transaction is appended by the OrderedListItemIndexPlugin, it's given the metadata:\n            // { \"orderedListIndexing\": true }\n            // These appended transactions happen immediately after any transaction which causes ordered list item\n            // indices to require updating, including those which trigger animations. Therefore, these animations are\n            // immediately overridden when the PreviousBlockTypePlugin processes the appended transaction, despite only\n            // the listItemIndex attribute changing. To solve this, oldAttrs must be edited for transactions with the\n            // \"orderedListIndexing\" metadata, so the correct animation can be re-triggered.\n            if (transaction.getMeta(\"numberedListIndexing\")) {\n              // If the block existed before the transaction, gets the attributes from before the previous transaction\n              // (i.e. the transaction that caused list item indices to need updating).\n              if (node.node.attrs.id in prev.prevTransactionOldBlockAttrs) {\n                oldAttrs =\n                  prev.prevTransactionOldBlockAttrs[node.node.attrs.id];\n              }\n\n              // Stops list item indices themselves being animated (looks smoother), unless the block's content type is\n              // changing from a numbered list item to something else.\n              if (newAttrs.type === \"numberedListItem\") {\n                oldAttrs.index = newAttrs.index;\n              }\n            }\n\n            prev.currentTransactionOldBlockAttrs[node.node.attrs.id] = oldAttrs;\n\n            // TODO: faster deep equal?\n            if (JSON.stringify(oldAttrs) !== JSON.stringify(newAttrs)) {\n              (oldAttrs as any)[\"depth-change\"] =\n                oldAttrs.depth - newAttrs.depth;\n\n              // for debugging:\n              // console.log(\n              //   \"id:\",\n              //   node.node.attrs.id,\n              //   \"previousBlockTypePlugin changes detected, oldAttrs\",\n              //   oldAttrs,\n              //   \"new\",\n              //   newAttrs\n              // );\n\n              prev.updatedBlocks.add(node.node.attrs.id);\n            }\n          }\n        }\n\n        prev.prevTransactionOldBlockAttrs =\n          currentTransactionOriginalOldBlockAttrs;\n\n        return prev;\n      },\n    },\n    props: {\n      decorations(state) {\n        const pluginState = (this as Plugin).getState(state);\n        if (pluginState.updatedBlocks.size === 0) {\n          return undefined;\n        }\n\n        const decorations: Decoration[] = [];\n\n        state.doc.descendants((node, pos) => {\n          if (!node.attrs.id) {\n            return;\n          }\n\n          if (!pluginState.updatedBlocks.has(node.attrs.id)) {\n            return;\n          }\n\n          const prevAttrs =\n            pluginState.currentTransactionOldBlockAttrs[node.attrs.id];\n          const decorationAttrs: any = {};\n\n          for (let [nodeAttr, val] of Object.entries(prevAttrs)) {\n            decorationAttrs[\"data-prev-\" + nodeAttributes[nodeAttr]] =\n              val || \"none\";\n          }\n\n          // for debugging:\n          // console.log(\n          //   \"previousBlockTypePlugin committing decorations\",\n          //   decorationAttrs\n          // );\n\n          const decoration = Decoration.node(pos, pos + node.nodeSize, {\n            ...decorationAttrs,\n          });\n\n          decorations.push(decoration);\n        });\n\n        return DecorationSet.create(state.doc, decorations);\n      },\n    },\n  });\n};\n","// Object containing all possible block attributes.\nconst BlockAttributes: Record<string, string> = {\n  blockColor: \"data-block-color\",\n  blockStyle: \"data-block-style\",\n  id: \"data-id\",\n  depth: \"data-depth\",\n  depthChange: \"data-depth-change\",\n};\n\nexport default BlockAttributes;\n","import { mergeAttributes, Node } from \"@tiptap/core\";\nimport { Fragment, Node as PMNode, Slice } from \"prosemirror-model\";\nimport { TextSelection } from \"prosemirror-state\";\nimport {\n  blockToNode,\n  inlineContentToNodes,\n} from \"../../../api/nodeConversions/nodeConversions\";\nimport { PartialBlock } from \"../api/blockTypes\";\nimport { getBlockInfoFromPos } from \"../helpers/getBlockInfoFromPos\";\nimport { PreviousBlockTypePlugin } from \"../PreviousBlockTypePlugin\";\nimport styles from \"./Block.module.css\";\nimport BlockAttributes from \"./BlockAttributes\";\n\n// TODO\nexport interface IBlock {\n  HTMLAttributes: Record<string, any>;\n}\n\ndeclare module \"@tiptap/core\" {\n  interface Commands<ReturnType> {\n    block: {\n      BNCreateBlock: (pos: number) => ReturnType;\n      BNDeleteBlock: (posInBlock: number) => ReturnType;\n      BNMergeBlocks: (posBetweenBlocks: number) => ReturnType;\n      BNSplitBlock: (posInBlock: number, keepType: boolean) => ReturnType;\n      BNUpdateBlock: (posInBlock: number, block: PartialBlock) => ReturnType;\n      BNCreateOrUpdateBlock: (\n        posInBlock: number,\n        block: PartialBlock\n      ) => ReturnType;\n    };\n  }\n}\n\n/**\n * The main \"Block node\" documents consist of\n */\nexport const BlockContainer = Node.create<IBlock>({\n  name: \"blockContainer\",\n  group: \"blockContainer\",\n  // A block always contains content, and optionally a blockGroup which contains nested blocks\n  content: \"blockContent blockGroup?\",\n  // Ensures content-specific keyboard handlers trigger first.\n  priority: 50,\n  defining: true,\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    };\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: \"div\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          const attrs: Record<string, string> = {};\n          for (let [nodeAttr, HTMLAttr] of Object.entries(BlockAttributes)) {\n            if (element.getAttribute(HTMLAttr)) {\n              attrs[nodeAttr] = element.getAttribute(HTMLAttr)!;\n            }\n          }\n\n          if (element.getAttribute(\"data-node-type\") === \"blockContainer\") {\n            return attrs;\n          }\n\n          return false;\n        },\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      \"div\",\n      mergeAttributes(HTMLAttributes, {\n        class: styles.blockOuter,\n        \"data-node-type\": \"block-outer\",\n      }),\n      [\n        \"div\",\n        mergeAttributes(HTMLAttributes, {\n          // TODO: maybe remove html attributes from inner block\n          class: styles.block,\n          \"data-node-type\": this.name,\n        }),\n        0,\n      ],\n    ];\n  },\n\n  addCommands() {\n    return {\n      // Creates a new text block at a given position.\n      BNCreateBlock:\n        (pos) =>\n        ({ state, dispatch }) => {\n          const newBlock =\n            state.schema.nodes[\"blockContainer\"].createAndFill()!;\n\n          if (dispatch) {\n            state.tr.insert(pos, newBlock);\n          }\n\n          return true;\n        },\n      // Deletes a block at a given position.\n      BNDeleteBlock:\n        (posInBlock) =>\n        ({ state, dispatch }) => {\n          const blockInfo = getBlockInfoFromPos(state.doc, posInBlock);\n          if (blockInfo === undefined) {\n            return false;\n          }\n\n          const { startPos, endPos } = blockInfo;\n\n          if (dispatch) {\n            state.tr.deleteRange(startPos, endPos);\n          }\n\n          return true;\n        },\n      // Updates a block at a given position.\n      BNUpdateBlock:\n        (posInBlock, block) =>\n        ({ state, dispatch }) => {\n          const blockInfo = getBlockInfoFromPos(state.doc, posInBlock);\n          if (blockInfo === undefined) {\n            return false;\n          }\n\n          const { startPos, endPos, node, contentNode } = blockInfo;\n\n          if (dispatch) {\n            // Adds blockGroup node with child blocks if necessary.\n            if (block.children !== undefined) {\n              const childNodes = [];\n\n              // Creates ProseMirror nodes for each child block, including their descendants.\n              for (const child of block.children) {\n                childNodes.push(blockToNode(child, state.schema));\n              }\n\n              // Checks if a blockGroup node already exists.\n              if (node.childCount === 2) {\n                // Replaces all child nodes in the existing blockGroup with the ones created earlier.\n                state.tr.replace(\n                  startPos + contentNode.nodeSize + 1,\n                  endPos - 1,\n                  new Slice(Fragment.from(childNodes), 0, 0)\n                );\n              } else {\n                // Inserts a new blockGroup containing the child nodes created earlier.\n                state.tr.insert(\n                  startPos + contentNode.nodeSize,\n                  state.schema.nodes[\"blockGroup\"].create({}, childNodes)\n                );\n              }\n            }\n\n            // Replaces the blockContent node's content if necessary.\n            if (block.content !== undefined) {\n              let content: PMNode[] = [];\n\n              // Checks if the provided content is a string or InlineContent[] type.\n              if (typeof block.content === \"string\") {\n                // Adds a single text node with no marks to the content.\n                content.push(state.schema.text(block.content));\n              } else {\n                // Adds a text node with the provided styles converted into marks to the content, for each InlineContent\n                // object.\n                content = inlineContentToNodes(block.content, state.schema);\n              }\n\n              // Replaces the contents of the blockContent node with the previously created text node(s).\n              state.tr.replace(\n                startPos + 1,\n                startPos + contentNode.nodeSize - 1,\n                new Slice(Fragment.from(content), 0, 0)\n              );\n            }\n\n            // Changes the blockContent node type and adds the provided props as attributes. Also preserves all existing\n            // attributes that are compatible with the new type.\n            state.tr.setNodeMarkup(\n              startPos,\n              block.type === undefined\n                ? undefined\n                : state.schema.nodes[block.type],\n              {\n                ...contentNode.attrs,\n                ...block.props,\n              }\n            );\n\n            // Adds all provided props as attributes to the parent blockContainer node too, and also preserves existing\n            // attributes.\n            state.tr.setNodeMarkup(startPos - 1, undefined, {\n              ...node.attrs,\n              ...block.props,\n            });\n          }\n\n          return true;\n        },\n      // Appends the text contents of a block to the nearest previous block, given a position between them. Children of\n      // the merged block are moved out of it first, rather than also being merged.\n      //\n      // In the example below, the position passed into the function is between Block1 and Block2.\n      //\n      // Block1\n      //    Block2\n      // Block3\n      //    Block4\n      //        Block5\n      //\n      // Becomes:\n      //\n      // Block1\n      //    Block2Block3\n      // Block4\n      //     Block5\n      BNMergeBlocks:\n        (posBetweenBlocks) =>\n        ({ state, dispatch }) => {\n          const nextNodeIsBlock =\n            state.doc.resolve(posBetweenBlocks + 1).node().type.name ===\n            \"blockContainer\";\n          const prevNodeIsBlock =\n            state.doc.resolve(posBetweenBlocks - 1).node().type.name ===\n            \"blockContainer\";\n\n          if (!nextNodeIsBlock || !prevNodeIsBlock) {\n            return false;\n          }\n\n          const nextBlockInfo = getBlockInfoFromPos(\n            state.doc,\n            posBetweenBlocks + 1\n          );\n\n          const { node, contentNode, startPos, endPos, depth } = nextBlockInfo!;\n\n          // Removes a level of nesting all children of the next block by 1 level, if it contains both content and block\n          // group nodes.\n          if (node.childCount === 2) {\n            const childBlocksStart = state.doc.resolve(\n              startPos + contentNode.nodeSize + 1\n            );\n            const childBlocksEnd = state.doc.resolve(endPos - 1);\n            const childBlocksRange =\n              childBlocksStart.blockRange(childBlocksEnd);\n\n            // Moves the block group node inside the block into the block group node that the current block is in.\n            if (dispatch) {\n              state.tr.lift(childBlocksRange!, depth - 1);\n            }\n          }\n\n          let prevBlockEndPos = posBetweenBlocks - 1;\n          let prevBlockInfo = getBlockInfoFromPos(state.doc, prevBlockEndPos);\n\n          // Finds the nearest previous block, regardless of nesting level.\n          while (prevBlockInfo!.numChildBlocks > 0) {\n            prevBlockEndPos--;\n            prevBlockInfo = getBlockInfoFromPos(state.doc, prevBlockEndPos);\n            if (prevBlockInfo === undefined) {\n              return false;\n            }\n          }\n\n          // Deletes next block and adds its text content to the nearest previous block.\n          // TODO: Use slices.\n          if (dispatch) {\n            state.tr.deleteRange(startPos, startPos + contentNode.nodeSize);\n            state.tr.insertText(contentNode.textContent, prevBlockEndPos - 1);\n            state.tr.setSelection(\n              new TextSelection(state.doc.resolve(prevBlockEndPos - 1))\n            );\n          }\n\n          return true;\n        },\n      // Splits a block at a given position. Content after the position is moved to a new block below, at the same\n      // nesting level.\n      BNSplitBlock:\n        (posInBlock, keepType) =>\n        ({ state, dispatch }) => {\n          const blockInfo = getBlockInfoFromPos(state.doc, posInBlock);\n          if (blockInfo === undefined) {\n            return false;\n          }\n\n          const { contentNode, contentType, startPos, endPos, depth } =\n            blockInfo;\n\n          const originalBlockContent = state.doc.cut(startPos + 1, posInBlock);\n          const newBlockContent = state.doc.cut(posInBlock, endPos - 1);\n\n          const newBlock =\n            state.schema.nodes[\"blockContainer\"].createAndFill()!;\n\n          const newBlockInsertionPos = endPos + 1;\n          const newBlockContentPos = newBlockInsertionPos + 2;\n\n          if (dispatch) {\n            // Creates a new block. Since the schema requires it to have a content node, a paragraph node is created\n            // automatically, spanning newBlockContentPos to newBlockContentPos + 1.\n            state.tr.insert(newBlockInsertionPos, newBlock);\n\n            // Replaces the content of the newly created block's content node. Doesn't replace the whole content node so\n            // its type doesn't change.\n            state.tr.replace(\n              newBlockContentPos,\n              newBlockContentPos + 1,\n              newBlockContent.content.size > 0\n                ? new Slice(\n                    Fragment.from(newBlockContent),\n                    depth + 2,\n                    depth + 2\n                  )\n                : undefined\n            );\n\n            // Changes the type of the content node. The range doesn't matter as long as both from and to positions are\n            // within the content node.\n            if (keepType) {\n              state.tr.setBlockType(\n                newBlockContentPos,\n                newBlockContentPos,\n                state.schema.node(contentType).type,\n                contentNode.attrs\n              );\n            }\n\n            // Sets the selection to the start of the new block's content node.\n            state.tr.setSelection(\n              new TextSelection(state.doc.resolve(newBlockContentPos))\n            );\n\n            // Replaces the content of the original block's content node. Doesn't replace the whole content node so its\n            // type doesn't change.\n            state.tr.replace(\n              startPos + 1,\n              endPos - 1,\n              originalBlockContent.content.size > 0\n                ? new Slice(\n                    Fragment.from(originalBlockContent),\n                    depth + 2,\n                    depth + 2\n                  )\n                : undefined\n            );\n          }\n\n          return true;\n        },\n    };\n  },\n\n  addProseMirrorPlugins() {\n    return [PreviousBlockTypePlugin()];\n  },\n\n  addKeyboardShortcuts() {\n    // handleBackspace is partially adapted from https://github.com/ueberdosis/tiptap/blob/ed56337470efb4fd277128ab7ef792b37cfae992/packages/core/src/extensions/keymap.ts\n    const handleBackspace = () =>\n      this.editor.commands.first(({ commands }) => [\n        // Deletes the selection if it's not empty.\n        () => commands.deleteSelection(),\n        // Undoes an input rule if one was triggered in the last editor state change.\n        () => commands.undoInputRule(),\n        // Reverts block content type to a paragraph if the selection is at the start of the block.\n        () =>\n          commands.command(({ state }) => {\n            const { contentType } = getBlockInfoFromPos(\n              state.doc,\n              state.selection.from\n            )!;\n\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n            const isParagraph = contentType.name === \"paragraph\";\n\n            if (selectionAtBlockStart && !isParagraph) {\n              return commands.BNUpdateBlock(state.selection.from, {\n                type: \"paragraph\",\n                props: {},\n              });\n            }\n\n            return false;\n          }),\n        // Removes a level of nesting if the block is indented if the selection is at the start of the block.\n        () =>\n          commands.command(({ state }) => {\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n\n            if (selectionAtBlockStart) {\n              return commands.liftListItem(\"blockContainer\");\n            }\n\n            return false;\n          }),\n        // Merges block with the previous one if it isn't indented, isn't the first block in the doc, and the selection\n        // is at the start of the block.\n        () =>\n          commands.command(({ state }) => {\n            const { depth, startPos } = getBlockInfoFromPos(\n              state.doc,\n              state.selection.from\n            )!;\n\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n            const selectionEmpty =\n              state.selection.anchor === state.selection.head;\n            const blockAtDocStart = startPos === 2;\n\n            const posBetweenBlocks = startPos - 1;\n\n            if (\n              !blockAtDocStart &&\n              selectionAtBlockStart &&\n              selectionEmpty &&\n              depth === 2\n            ) {\n              return commands.BNMergeBlocks(posBetweenBlocks);\n            }\n\n            return false;\n          }),\n      ]);\n\n    const handleEnter = () =>\n      this.editor.commands.first(({ commands }) => [\n        // Removes a level of nesting if the block is empty & indented, while the selection is also empty & at the start\n        // of the block.\n        () =>\n          commands.command(({ state }) => {\n            const { node, depth } = getBlockInfoFromPos(\n              state.doc,\n              state.selection.from\n            )!;\n\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n            const selectionEmpty =\n              state.selection.anchor === state.selection.head;\n            const blockEmpty = node.textContent.length === 0;\n            const blockIndented = depth > 2;\n\n            if (\n              selectionAtBlockStart &&\n              selectionEmpty &&\n              blockEmpty &&\n              blockIndented\n            ) {\n              return commands.liftListItem(\"blockContainer\");\n            }\n\n            return false;\n          }),\n        // Creates a new block and moves the selection to it if the current one is empty, while the selection is also\n        // empty & at the start of the block.\n        () =>\n          commands.command(({ state, chain }) => {\n            const { node, endPos } = getBlockInfoFromPos(\n              state.doc,\n              state.selection.from\n            )!;\n\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n            const selectionEmpty =\n              state.selection.anchor === state.selection.head;\n            const blockEmpty = node.textContent.length === 0;\n\n            if (selectionAtBlockStart && selectionEmpty && blockEmpty) {\n              const newBlockInsertionPos = endPos + 1;\n              const newBlockContentPos = newBlockInsertionPos + 2;\n\n              chain()\n                .BNCreateBlock(newBlockInsertionPos)\n                .setTextSelection(newBlockContentPos)\n                .run();\n\n              return true;\n            }\n\n            return false;\n          }),\n        // Splits the current block, moving content inside that's after the cursor to a new text block below. Also\n        // deletes the selection beforehand, if it's not empty.\n        () =>\n          commands.command(({ state, chain }) => {\n            const { node } = getBlockInfoFromPos(\n              state.doc,\n              state.selection.from\n            )!;\n\n            const blockEmpty = node.textContent.length === 0;\n\n            if (!blockEmpty) {\n              chain()\n                .deleteSelection()\n                .BNSplitBlock(state.selection.from, false)\n                .run();\n\n              return true;\n            }\n\n            return false;\n          }),\n      ]);\n\n    return {\n      Backspace: handleBackspace,\n      Enter: handleEnter,\n      // Always returning true for tab key presses ensures they're not captured by the browser. Otherwise, they blur the\n      // editor since the browser will try to use tab for keyboard navigation.\n      Tab: () => {\n        this.editor.commands.sinkListItem(\"blockContainer\");\n        return true;\n      },\n      \"Shift-Tab\": () => {\n        this.editor.commands.liftListItem(\"blockContainer\");\n        return true;\n      },\n      \"Mod-Alt-0\": () =>\n        this.editor.commands.BNCreateBlock(\n          this.editor.state.selection.anchor + 2\n        ),\n      \"Mod-Alt-1\": () =>\n        this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n          type: \"heading\",\n          props: {\n            level: \"1\",\n          },\n        }),\n      \"Mod-Alt-2\": () =>\n        this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n          type: \"heading\",\n          props: {\n            level: \"2\",\n          },\n        }),\n      \"Mod-Alt-3\": () =>\n        this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n          type: \"heading\",\n          props: {\n            level: \"3\",\n          },\n        }),\n      \"Mod-Shift-7\": () =>\n        this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n          type: \"bulletListItem\",\n          props: {},\n        }),\n      \"Mod-Shift-8\": () =>\n        this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n          type: \"numberedListItem\",\n          props: {},\n        }),\n    };\n  },\n});\n","import { mergeAttributes, Node } from \"@tiptap/core\";\nimport styles from \"./Block.module.css\";\n\nexport const BlockGroup = Node.create({\n  name: \"blockGroup\",\n  group: \"blockGroup\",\n  content: \"blockContainer+\",\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    };\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: \"div\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          if (element.getAttribute(\"data-node-type\") === \"blockGroup\") {\n            // Null means the element matches, but we don't want to add any attributes to the node.\n            return null;\n          }\n\n          return false;\n        },\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      \"div\",\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n        class: styles.blockGroup,\n        \"data-node-type\": \"blockGroup\",\n      }),\n      0,\n    ];\n  },\n});\n","import { mergeAttributes, Node } from \"@tiptap/core\";\nimport styles from \"../../Block.module.css\";\n\nexport const ParagraphBlockContent = Node.create({\n  name: \"paragraph\",\n  group: \"blockContent\",\n  content: \"inline*\",\n\n  parseHTML() {\n    return [\n      {\n        tag: \"p\",\n        priority: 200,\n        node: \"paragraph\",\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      \"div\",\n      mergeAttributes(HTMLAttributes, {\n        class: styles.blockContent,\n        \"data-content-type\": this.name,\n      }),\n      [\"p\", 0],\n    ];\n  },\n});\n","import { InputRule, mergeAttributes, Node } from \"@tiptap/core\";\nimport styles from \"../../Block.module.css\";\n\nexport const HeadingBlockContent = Node.create({\n  name: \"heading\",\n  group: \"blockContent\",\n  content: \"inline*\",\n\n  addAttributes() {\n    return {\n      level: {\n        default: \"1\",\n        // instead of \"level\" attributes, use \"data-level\"\n        parseHTML: (element) => element.getAttribute(\"data-level\"),\n        renderHTML: (attributes) => {\n          return {\n            \"data-level\": attributes.level,\n          };\n        },\n      },\n    };\n  },\n\n  addInputRules() {\n    return [\n      ...[\"1\", \"2\", \"3\"].map((level) => {\n        // Creates a heading of appropriate level when starting with \"#\", \"##\", or \"###\".\n        return new InputRule({\n          find: new RegExp(`^(#{${parseInt(level)}})\\\\s$`),\n          handler: ({ state, chain, range }) => {\n            chain()\n              .BNUpdateBlock(state.selection.from, {\n                type: \"heading\",\n                props: {\n                  level: level as \"1\" | \"2\" | \"3\",\n                },\n              })\n              // Removes the \"#\" character(s) used to set the heading.\n              .deleteRange({ from: range.from, to: range.to });\n          },\n        });\n      }),\n    ];\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: \"h1\",\n        attrs: { level: \"1\" },\n        node: \"heading\",\n      },\n      {\n        tag: \"h2\",\n        attrs: { level: \"2\" },\n        node: \"heading\",\n      },\n      {\n        tag: \"h3\",\n        attrs: { level: \"3\" },\n        node: \"heading\",\n      },\n    ];\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      \"div\",\n      mergeAttributes(HTMLAttributes, {\n        class: styles.blockContent,\n        \"data-content-type\": this.name,\n      }),\n      [\"h\" + node.attrs.level, 0],\n    ];\n  },\n});\n","import { Editor } from \"@tiptap/core\";\nimport { getBlockInfoFromPos } from \"../../../helpers/getBlockInfoFromPos\";\n\nexport const handleEnter = (editor: Editor) => {\n  const { node, contentType } = getBlockInfoFromPos(\n    editor.state.doc,\n    editor.state.selection.from\n  )!;\n\n  const selectionEmpty =\n    editor.state.selection.anchor === editor.state.selection.head;\n\n  if (!contentType.name.endsWith(\"ListItem\") || !selectionEmpty) {\n    return false;\n  }\n\n  return editor.commands.first(({ state, chain, commands }) => [\n    () =>\n      // Changes list item block to a text block if the content is empty.\n      commands.command(() => {\n        if (node.textContent.length === 0) {\n          return commands.BNUpdateBlock(state.selection.from, {\n            type: \"paragraph\",\n            props: {},\n          });\n        }\n\n        return false;\n      }),\n\n    () =>\n      // Splits the current block, moving content inside that's after the cursor to a new block of the same type\n      // below.\n      commands.command(() => {\n        if (node.textContent.length > 0) {\n          chain()\n            .deleteSelection()\n            .BNSplitBlock(state.selection.from, true)\n            .run();\n\n          return true;\n        }\n\n        return false;\n      }),\n  ]);\n};\n","import { InputRule, mergeAttributes, Node } from \"@tiptap/core\";\nimport styles from \"../../../Block.module.css\";\nimport { handleEnter } from \"../ListItemKeyboardShortcuts\";\n\nexport const BulletListItemBlockContent = Node.create({\n  name: \"bulletListItem\",\n  group: \"blockContent\",\n  content: \"inline*\",\n\n  addInputRules() {\n    return [\n      // Creates an unordered list when starting with \"-\", \"+\", or \"*\".\n      new InputRule({\n        find: new RegExp(`^[-+*]\\\\s$`),\n        handler: ({ state, chain, range }) => {\n          chain()\n            .BNUpdateBlock(state.selection.from, {\n              type: \"bulletListItem\",\n              props: {},\n            })\n            // Removes the \"-\", \"+\", or \"*\" character used to set the list.\n            .deleteRange({ from: range.from, to: range.to });\n        },\n      }),\n    ];\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => handleEnter(this.editor),\n    };\n  },\n\n  parseHTML() {\n    return [\n      // Case for regular HTML list structure.\n      {\n        tag: \"li\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          const parent = element.parentElement;\n\n          if (parent === null) {\n            return false;\n          }\n\n          if (parent.tagName === \"UL\") {\n            return {};\n          }\n\n          return false;\n        },\n        node: \"bulletListItem\",\n      },\n      // Case for BlockNote list structure.\n      {\n        tag: \"p\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          const parent = element.parentElement;\n\n          if (parent === null) {\n            return false;\n          }\n\n          if (parent.getAttribute(\"data-content-type\") === \"bulletListItem\") {\n            return {};\n          }\n\n          return false;\n        },\n        priority: 300,\n        node: \"bulletListItem\",\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      \"div\",\n      mergeAttributes(HTMLAttributes, {\n        class: styles.blockContent,\n        \"data-content-type\": this.name,\n      }),\n      [\"p\", 0],\n    ];\n  },\n});\n","import { Plugin, PluginKey } from \"prosemirror-state\";\nimport { getBlockInfoFromPos } from \"../../../../helpers/getBlockInfoFromPos\";\n\n// ProseMirror Plugin which automatically assigns indices to ordered list items per nesting level.\nconst PLUGIN_KEY = new PluginKey(`numbered-list-indexing`);\nexport const NumberedListIndexingPlugin = () => {\n  return new Plugin({\n    key: PLUGIN_KEY,\n    appendTransaction: (_transactions, _oldState, newState) => {\n      const tr = newState.tr;\n      tr.setMeta(\"numberedListIndexing\", true);\n\n      let modified = false;\n\n      // Traverses each node the doc using DFS, so blocks which are on the same nesting level will be traversed in the\n      // same order they appear. This means the index of each list item block can be calculated by incrementing the\n      // index of the previous list item block.\n      newState.doc.descendants((node, pos) => {\n        if (\n          node.type.name === \"blockContainer\" &&\n          node.firstChild!.type.name === \"numberedListItem\"\n        ) {\n          let newIndex = \"1\";\n          const isFirstBlockInDoc = pos === 1;\n\n          const blockInfo = getBlockInfoFromPos(tr.doc, pos + 1)!;\n          if (blockInfo === undefined) {\n            return;\n          }\n\n          // Checks if this block is the start of a new ordered list, i.e. if it's the first block in the document, the\n          // first block in its nesting level, or the previous block is not an ordered list item.\n          if (!isFirstBlockInDoc) {\n            const prevBlockInfo = getBlockInfoFromPos(tr.doc, pos - 2)!;\n            if (prevBlockInfo === undefined) {\n              return;\n            }\n\n            const isFirstBlockInNestingLevel =\n              blockInfo.depth !== prevBlockInfo.depth;\n\n            if (!isFirstBlockInNestingLevel) {\n              const prevBlockContentNode = prevBlockInfo.contentNode;\n              const prevBlockContentType = prevBlockInfo.contentType;\n\n              const isPrevBlockOrderedListItem =\n                prevBlockContentType.name === \"numberedListItem\";\n\n              if (isPrevBlockOrderedListItem) {\n                const prevBlockIndex = prevBlockContentNode.attrs[\"index\"];\n\n                newIndex = (parseInt(prevBlockIndex) + 1).toString();\n              }\n            }\n          }\n\n          const contentNode = blockInfo.contentNode;\n          const index = contentNode.attrs[\"index\"];\n\n          if (index !== newIndex) {\n            modified = true;\n\n            tr.setNodeMarkup(pos + 1, undefined, {\n              index: newIndex,\n            });\n          }\n        }\n      });\n\n      return modified ? tr : null;\n    },\n  });\n};\n","import { InputRule, mergeAttributes, Node } from \"@tiptap/core\";\nimport styles from \"../../../Block.module.css\";\nimport { handleEnter } from \"../ListItemKeyboardShortcuts\";\nimport { NumberedListIndexingPlugin } from \"./NumberedListIndexingPlugin\";\n\nexport const NumberedListItemBlockContent = Node.create({\n  name: \"numberedListItem\",\n  group: \"blockContent\",\n  content: \"inline*\",\n\n  addAttributes() {\n    return {\n      index: {\n        default: null,\n        parseHTML: (element) => element.getAttribute(\"data-index\"),\n        renderHTML: (attributes) => {\n          return {\n            \"data-index\": attributes.index,\n          };\n        },\n      },\n    };\n  },\n\n  addInputRules() {\n    return [\n      // Creates an ordered list when starting with \"1.\".\n      new InputRule({\n        find: new RegExp(`^1\\\\.\\\\s$`),\n        handler: ({ state, chain, range }) => {\n          chain()\n            .BNUpdateBlock(state.selection.from, {\n              type: \"numberedListItem\",\n              props: {},\n            })\n            // Removes the \"1.\" characters used to set the list.\n            .deleteRange({ from: range.from, to: range.to });\n        },\n      }),\n    ];\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => handleEnter(this.editor),\n    };\n  },\n\n  addProseMirrorPlugins() {\n    return [NumberedListIndexingPlugin()];\n  },\n\n  parseHTML() {\n    return [\n      // Case for regular HTML list structure.\n      // (e.g.: when pasting from other apps)\n      {\n        tag: \"li\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          const parent = element.parentElement;\n\n          if (parent === null) {\n            return false;\n          }\n\n          if (parent.tagName === \"OL\") {\n            return {};\n          }\n\n          return false;\n        },\n        node: \"numberedListItem\",\n      },\n      // Case for BlockNote list structure.\n      // (e.g.: when pasting from blocknote)\n      {\n        tag: \"p\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          const parent = element.parentElement;\n\n          if (parent === null) {\n            return false;\n          }\n\n          if (parent.getAttribute(\"data-content-type\") === \"numberedListItem\") {\n            return {};\n          }\n\n          return false;\n        },\n        priority: 300,\n        node: \"numberedListItem\",\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      \"div\",\n      mergeAttributes(HTMLAttributes, {\n        class: styles.blockContent,\n        \"data-content-type\": this.name,\n      }),\n      // we use a <p> tag, because for <li> tags we'd need to add a <ul> parent for around siblings to be semantically correct,\n      // which would be quite cumbersome\n      [\"p\", 0],\n    ];\n  },\n});\n","import { Node } from \"@tiptap/core\";\nimport { BlockContainer } from \"./nodes/BlockContainer\";\nimport { BlockGroup } from \"./nodes/BlockGroup\";\nimport { ParagraphBlockContent } from \"./nodes/BlockContent/ParagraphBlockContent/ParagraphBlockContent\";\nimport { HeadingBlockContent } from \"./nodes/BlockContent/HeadingBlockContent/HeadingBlockContent\";\nimport { BulletListItemBlockContent } from \"./nodes/BlockContent/ListItemBlockContent/BulletListItemBlockContent/BulletListItemBlockContent\";\nimport { NumberedListItemBlockContent } from \"./nodes/BlockContent/ListItemBlockContent/NumberedListItemBlockContent/NumberedListItemBlockContent\";\n\nexport const blocks: any[] = [\n  ParagraphBlockContent,\n  HeadingBlockContent,\n  BulletListItemBlockContent,\n  NumberedListItemBlockContent,\n  BlockContainer,\n  BlockGroup,\n  Node.create({\n    name: \"doc\",\n    topNode: true,\n    content: \"blockGroup\",\n  }),\n];\n","import { findParentNode } from \"@tiptap/core\";\n\nexport const findBlock = findParentNode(\n  (node) => node.type.name === \"blockContainer\"\n);\n","import { Editor, Range } from \"@tiptap/core\";\nimport { EditorState, Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet, EditorView } from \"prosemirror-view\";\nimport { findBlock } from \"../../../extensions/Blocks/helpers/findBlock\";\nimport {\n  SuggestionsMenu,\n  SuggestionsMenuDynamicParams,\n  SuggestionsMenuFactory,\n  SuggestionsMenuStaticParams,\n} from \"./SuggestionsMenuFactoryTypes\";\nimport { SuggestionItem } from \"./SuggestionItem\";\nimport { BlockNoteEditor } from \"../../../BlockNoteEditor\";\n\nexport type SuggestionPluginOptions<T extends SuggestionItem> = {\n  /**\n   * The name of the plugin.\n   *\n   * Used for ensuring that the plugin key is unique when more than one instance of the SuggestionPlugin is used.\n   */\n  pluginKey: PluginKey;\n\n  /**\n   * The BlockNote editor.\n   */\n  editor: BlockNoteEditor;\n\n  /**\n   * The character that should trigger the suggestion menu to pop up (e.g. a '/' for commands), when typed by the user.\n   */\n  defaultTriggerCharacter: string;\n\n  suggestionsMenuFactory: SuggestionsMenuFactory<T>;\n\n  /**\n   * The callback that gets executed when an item is selected by the user.\n   *\n   * **NOTE:** The command text is not removed automatically from the editor by this plugin,\n   * this should be done manually. The `editor` and `range` properties passed\n   * to the callback function might come in handy when doing this.\n   */\n  onSelectItem?: (props: { item: T; editor: BlockNoteEditor }) => void;\n\n  /**\n   * A function that should supply the plugin with items to suggest, based on a certain query string.\n   */\n  items?: (query: string) => T[];\n\n  allow?: (props: { editor: Editor; range: Range }) => boolean;\n};\n\ntype SuggestionPluginState<T extends SuggestionItem> = {\n  // True when the menu is shown, false when hidden.\n  active: boolean;\n  // The character that triggered the menu being shown. Allowing the trigger to be different to the default\n  // trigger allows other extensions to open it programmatically.\n  triggerCharacter: string | undefined;\n  // The editor position just after the trigger character, i.e. where the user query begins. Used to figure out\n  // which menu items to show and can also be used to delete the trigger character.\n  queryStartPos: number | undefined;\n  // The items that should be shown in the menu.\n  items: T[];\n  // The index of the item in the menu that's currently hovered using the keyboard.\n  keyboardHoveredItemIndex: number | undefined;\n  // The number of characters typed after the last query that matched with at least 1 item. Used to close the\n  // menu if the user keeps entering queries that don't return any results.\n  notFoundCount: number | undefined;\n  decorationId: string | undefined;\n};\n\nfunction getDefaultPluginState<\n  T extends SuggestionItem\n>(): SuggestionPluginState<T> {\n  return {\n    active: false,\n    triggerCharacter: undefined,\n    queryStartPos: undefined,\n    items: [] as T[],\n    keyboardHoveredItemIndex: undefined,\n    notFoundCount: 0,\n    decorationId: undefined,\n  };\n}\n\ntype SuggestionPluginViewOptions<T extends SuggestionItem> = {\n  editor: BlockNoteEditor;\n  pluginKey: PluginKey;\n  onSelectItem: (props: { item: T; editor: BlockNoteEditor }) => void;\n  suggestionsMenuFactory: SuggestionsMenuFactory<T>;\n};\n\nclass SuggestionPluginView<T extends SuggestionItem> {\n  editor: BlockNoteEditor;\n  pluginKey: PluginKey;\n\n  suggestionsMenu: SuggestionsMenu<T>;\n\n  pluginState: SuggestionPluginState<T>;\n  itemCallback: (item: T) => void;\n\n  constructor({\n    editor,\n    pluginKey,\n    onSelectItem: selectItemCallback = () => {},\n    suggestionsMenuFactory,\n  }: SuggestionPluginViewOptions<T>) {\n    this.editor = editor;\n    this.pluginKey = pluginKey;\n\n    this.pluginState = getDefaultPluginState<T>();\n\n    this.itemCallback = (item: T) => {\n      editor._tiptapEditor\n        .chain()\n        .focus()\n        .deleteRange({\n          from:\n            this.pluginState.queryStartPos! -\n            this.pluginState.triggerCharacter!.length,\n          to: editor._tiptapEditor.state.selection.from,\n        })\n        .run();\n\n      selectItemCallback({\n        item: item,\n        editor: editor,\n      });\n    };\n\n    this.suggestionsMenu = suggestionsMenuFactory(this.getStaticParams());\n\n    document.addEventListener(\"scroll\", this.handleScroll);\n  }\n\n  handleScroll = () => {\n    if (this.pluginKey.getState(this.editor._tiptapEditor.state).active) {\n      this.suggestionsMenu.render(this.getDynamicParams(), false);\n    }\n  };\n\n  update(view: EditorView, prevState: EditorState) {\n    const prev = this.pluginKey.getState(prevState);\n    const next = this.pluginKey.getState(view.state);\n\n    // See how the state changed\n    const started = !prev.active && next.active;\n    const stopped = prev.active && !next.active;\n    // TODO: Currently also true for cases in which an update isn't needed so selected list item index updates still\n    //  cause the view to update. May need to be more strict.\n    const changed = prev.active && next.active;\n\n    // Cancel when suggestion isn't active\n    if (!started && !changed && !stopped) {\n      return;\n    }\n\n    this.pluginState = stopped ? prev : next;\n\n    if (stopped || !this.editor.isEditable) {\n      this.suggestionsMenu.hide();\n\n      // Listener stops focus moving to the menu on click.\n      this.suggestionsMenu.element!.removeEventListener(\"mousedown\", (event) =>\n        event.preventDefault()\n      );\n    }\n\n    if (changed) {\n      this.suggestionsMenu.render(this.getDynamicParams(), false);\n    }\n\n    if (started && this.editor.isEditable) {\n      this.suggestionsMenu.render(this.getDynamicParams(), true);\n\n      // Listener stops focus moving to the menu on click.\n      this.suggestionsMenu.element!.addEventListener(\"mousedown\", (event) =>\n        event.preventDefault()\n      );\n    }\n  }\n\n  destroy() {\n    document.removeEventListener(\"scroll\", this.handleScroll);\n  }\n\n  getStaticParams(): SuggestionsMenuStaticParams<T> {\n    return {\n      itemCallback: (item: T) => this.itemCallback(item),\n    };\n  }\n\n  getDynamicParams(): SuggestionsMenuDynamicParams<T> {\n    const decorationNode = document.querySelector(\n      `[data-decoration-id=\"${this.pluginState.decorationId}\"]`\n    );\n\n    return {\n      items: this.pluginState.items,\n      keyboardHoveredItemIndex: this.pluginState.keyboardHoveredItemIndex!,\n      referenceRect: decorationNode!.getBoundingClientRect(),\n    };\n  }\n}\n\n/**\n * A ProseMirror plugin for suggestions, designed to make '/'-commands possible as well as mentions.\n *\n * This is basically a simplified version of TipTap's [Suggestions](https://github.com/ueberdosis/tiptap/tree/db92a9b313c5993b723c85cd30256f1d4a0b65e1/packages/suggestion) plugin.\n *\n * This version is adapted from the aforementioned version in the following ways:\n * - This version supports generic items instead of only strings (to allow for more advanced filtering for example)\n * - This version hides some unnecessary complexity from the user of the plugin.\n * - This version handles key events differently\n *\n * @param options options for configuring the plugin\n * @returns the prosemirror plugin\n */\nexport function createSuggestionPlugin<T extends SuggestionItem>({\n  pluginKey,\n  editor,\n  defaultTriggerCharacter,\n  suggestionsMenuFactory,\n  onSelectItem: selectItemCallback = () => {},\n  items = () => [],\n}: SuggestionPluginOptions<T>) {\n  // Assertions\n  if (defaultTriggerCharacter.length !== 1) {\n    throw new Error(\"'char' should be a single character\");\n  }\n\n  const deactivate = (view: EditorView) => {\n    view.dispatch(view.state.tr.setMeta(pluginKey, { deactivate: true }));\n  };\n\n  // Plugin key is passed in as a parameter, so it can be exported and used in the DraggableBlocksPlugin.\n  return new Plugin({\n    key: pluginKey,\n\n    view: (view: EditorView) =>\n      new SuggestionPluginView({\n        editor: editor,\n        pluginKey: pluginKey,\n        onSelectItem: (props: { item: T; editor: BlockNoteEditor }) => {\n          deactivate(view);\n          selectItemCallback(props);\n        },\n        suggestionsMenuFactory: suggestionsMenuFactory,\n      }),\n\n    state: {\n      // Initialize the plugin's internal state.\n      init(): SuggestionPluginState<T> {\n        return getDefaultPluginState<T>();\n      },\n\n      // Apply changes to the plugin state from an editor transaction.\n      apply(transaction, prev, oldState, newState): SuggestionPluginState<T> {\n        // TODO: More clearly define which transactions should be ignored.\n        if (transaction.getMeta(\"orderedListIndexing\") !== undefined) {\n          return prev;\n        }\n\n        // Checks if the menu should be shown.\n        if (transaction.getMeta(pluginKey)?.activate) {\n          return {\n            active: true,\n            triggerCharacter:\n              transaction.getMeta(pluginKey)?.triggerCharacter || \"\",\n            queryStartPos: newState.selection.from,\n            items: items(\"\"),\n            keyboardHoveredItemIndex: 0,\n            // TODO: Maybe should be 1 if the menu has no possible items? Probably redundant since a menu with no items\n            //  is useless in practice.\n            notFoundCount: 0,\n            decorationId: `id_${Math.floor(Math.random() * 0xffffffff)}`,\n          };\n        }\n\n        // Checks if the menu is hidden, in which case it doesn't need to be hidden or updated.\n        if (!prev.active) {\n          return prev;\n        }\n\n        const next = { ...prev };\n\n        // Updates which menu items to show by checking which items the current query (the text between the trigger\n        // character and caret) matches with.\n        next.items = items(\n          newState.doc.textBetween(prev.queryStartPos!, newState.selection.from)\n        );\n\n        // Updates notFoundCount if the query doesn't match any items.\n        next.notFoundCount = 0;\n        if (next.items.length === 0) {\n          // Checks how many characters were typed or deleted since the last transaction, and updates the notFoundCount\n          // accordingly. Also ensures the notFoundCount does not become negative.\n          next.notFoundCount = Math.max(\n            0,\n            prev.notFoundCount! +\n              (newState.selection.from - oldState.selection.from)\n          );\n        }\n\n        // Hides the menu. This is done after items and notFoundCount are already updated as notFoundCount is needed to\n        // check if the menu should be hidden.\n        if (\n          // Highlighting text should hide the menu.\n          newState.selection.from !== newState.selection.to ||\n          // Transactions with plugin metadata {deactivate: true} should hide the menu.\n          transaction.getMeta(pluginKey)?.deactivate ||\n          // Certain mouse events should hide the menu.\n          // TODO: Change to global mousedown listener.\n          transaction.getMeta(\"focus\") ||\n          transaction.getMeta(\"blur\") ||\n          transaction.getMeta(\"pointer\") ||\n          // Moving the caret before the character which triggered the menu should hide it.\n          (prev.active && newState.selection.from < prev.queryStartPos!) ||\n          // Entering more than 3 characters, after the last query that matched with at least 1 menu item, should hide\n          // the menu.\n          next.notFoundCount > 3\n        ) {\n          return getDefaultPluginState<T>();\n        }\n\n        // Updates keyboardHoveredItemIndex if necessary.\n        if (\n          transaction.getMeta(pluginKey)?.selectedItemIndexChanged !== undefined\n        ) {\n          let newIndex =\n            transaction.getMeta(pluginKey).selectedItemIndexChanged;\n\n          // Allows selection to jump between first and last items.\n          if (newIndex < 0) {\n            newIndex = prev.items.length - 1;\n          } else if (newIndex >= prev.items.length) {\n            newIndex = 0;\n          }\n\n          next.keyboardHoveredItemIndex = newIndex;\n        }\n\n        return next;\n      },\n    },\n\n    props: {\n      handleKeyDown(view, event) {\n        const menuIsActive = (this as Plugin).getState(view.state).active;\n\n        // Shows the menu if the default trigger character was pressed and the menu isn't active.\n        if (event.key === defaultTriggerCharacter && !menuIsActive) {\n          view.dispatch(\n            view.state.tr\n              .insertText(defaultTriggerCharacter)\n              .scrollIntoView()\n              .setMeta(pluginKey, {\n                activate: true,\n                triggerCharacter: defaultTriggerCharacter,\n              })\n          );\n\n          return true;\n        }\n\n        // Doesn't handle other keystrokes if the menu isn't active.\n        if (!menuIsActive) {\n          return false;\n        }\n\n        // Handles keystrokes for navigating the menu.\n        const {\n          triggerCharacter,\n          queryStartPos,\n          items,\n          keyboardHoveredItemIndex,\n        } = pluginKey.getState(view.state);\n\n        // Moves the keyboard selection to the previous item.\n        if (event.key === \"ArrowUp\") {\n          view.dispatch(\n            view.state.tr.setMeta(pluginKey, {\n              selectedItemIndexChanged: keyboardHoveredItemIndex - 1,\n            })\n          );\n          return true;\n        }\n\n        // Moves the keyboard selection to the next item.\n        if (event.key === \"ArrowDown\") {\n          view.dispatch(\n            view.state.tr.setMeta(pluginKey, {\n              selectedItemIndexChanged: keyboardHoveredItemIndex + 1,\n            })\n          );\n          return true;\n        }\n\n        // Selects an item and closes the menu.\n        if (event.key === \"Enter\") {\n          deactivate(view);\n          editor._tiptapEditor\n            .chain()\n            .focus()\n            .deleteRange({\n              from: queryStartPos! - triggerCharacter!.length,\n              to: editor._tiptapEditor.state.selection.from,\n            })\n            .run();\n\n          selectItemCallback({\n            item: items[keyboardHoveredItemIndex],\n            editor: editor,\n          });\n\n          return true;\n        }\n\n        // Closes the menu.\n        if (event.key === \"Escape\") {\n          deactivate(view);\n          return true;\n        }\n\n        return false;\n      },\n\n      // Hides menu in cases where mouse click does not cause an editor state change.\n      handleClick(view) {\n        deactivate(view);\n      },\n\n      // Setup decorator on the currently active suggestion.\n      decorations(state) {\n        const { active, decorationId, queryStartPos, triggerCharacter } = (\n          this as Plugin\n        ).getState(state);\n\n        if (!active) {\n          return null;\n        }\n\n        // If the menu was opened programmatically by another extension, it may not use a trigger character. In this\n        // case, the decoration is set on the whole block instead, as the decoration range would otherwise be empty.\n        if (triggerCharacter === \"\") {\n          const blockNode = findBlock(state.selection);\n          if (blockNode) {\n            return DecorationSet.create(state.doc, [\n              Decoration.node(\n                blockNode.pos,\n                blockNode.pos + blockNode.node.nodeSize,\n                {\n                  nodeName: \"span\",\n                  class: \"suggestion-decorator\",\n                  \"data-decoration-id\": decorationId,\n                }\n              ),\n            ]);\n          }\n        }\n        // Creates an inline decoration around the trigger character.\n        return DecorationSet.create(state.doc, [\n          Decoration.inline(\n            queryStartPos - triggerCharacter.length,\n            queryStartPos,\n            {\n              nodeName: \"span\",\n              class: \"suggestion-decorator\",\n              \"data-decoration-id\": decorationId,\n            }\n          ),\n        ]);\n      },\n    },\n  });\n}\n","import { Extension } from \"@tiptap/core\";\nimport { PluginKey } from \"prosemirror-state\";\nimport { createSuggestionPlugin } from \"../../shared/plugins/suggestion/SuggestionPlugin\";\nimport { SuggestionsMenuFactory } from \"../../shared/plugins/suggestion/SuggestionsMenuFactoryTypes\";\nimport { BaseSlashMenuItem } from \"./BaseSlashMenuItem\";\nimport { BlockNoteEditor } from \"../../BlockNoteEditor\";\n\nexport type SlashMenuOptions = {\n  editor: BlockNoteEditor | undefined;\n  commands: BaseSlashMenuItem[] | undefined;\n  slashMenuFactory: SuggestionsMenuFactory<any> | undefined;\n};\n\nexport const SlashMenuPluginKey = new PluginKey(\"suggestions-slash-commands\");\n\nexport const SlashMenuExtension = Extension.create<SlashMenuOptions>({\n  name: \"slash-command\",\n\n  addOptions() {\n    return {\n      editor: undefined,\n      commands: undefined,\n      slashMenuFactory: undefined,\n    };\n  },\n\n  addProseMirrorPlugins() {\n    if (!this.options.slashMenuFactory || !this.options.commands) {\n      throw new Error(\"required args not defined for SlashMenuExtension\");\n    }\n\n    const commands = this.options.commands;\n\n    return [\n      createSuggestionPlugin<BaseSlashMenuItem>({\n        pluginKey: SlashMenuPluginKey,\n        editor: this.options.editor!,\n        defaultTriggerCharacter: \"/\",\n        suggestionsMenuFactory: this.options.slashMenuFactory!,\n        items: (query) => {\n          return commands.filter((cmd: BaseSlashMenuItem) => cmd.match(query));\n        },\n        onSelectItem: ({ item, editor }) => {\n          item.execute(editor);\n        },\n      }),\n    ];\n  },\n});\n","import { Selection } from \"prosemirror-state\";\nimport { Fragment, Node, ResolvedPos, Slice } from \"prosemirror-model\";\nimport { Mappable } from \"prosemirror-transform\";\n\n/**\n * This class represents an editor selection which spans multiple nodes/blocks. It's currently only used to allow users\n * to drag multiple blocks at the same time. Expects the selection anchor and head to be between nodes, i.e. just before\n * the first target node and just after the last, and that anchor and head are at the same nesting level.\n *\n * Partially based on ProseMirror's NodeSelection implementation:\n * (https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.ts)\n * MultipleNodeSelection differs from NodeSelection in the following ways:\n * 1. Stores which nodes are included in the selection instead of just a single node.\n * 2. Already expects the selection to start just before the first target node and ends just after the last, while a\n * NodeSelection automatically sets both anchor and head to just before the single target node.\n */\nexport class MultipleNodeSelection extends Selection {\n  nodes: Array<Node>;\n\n  constructor($anchor: ResolvedPos, $head: ResolvedPos) {\n    super($anchor, $head);\n\n    // Parent is at the same nesting level as anchor/head since they are just before/ just after target nodes.\n    const parentNode = $anchor.node();\n\n    this.nodes = [];\n    $anchor.doc.nodesBetween($anchor.pos, $head.pos, (node, _pos, parent) => {\n      if (parent !== null && parent.eq(parentNode)) {\n        this.nodes.push(node);\n        return false;\n      }\n      return;\n    });\n  }\n\n  static create(doc: Node, from: number, to = from): MultipleNodeSelection {\n    return new MultipleNodeSelection(doc.resolve(from), doc.resolve(to));\n  }\n\n  content(): Slice {\n    return new Slice(Fragment.from(this.nodes), 0, 0);\n  }\n\n  eq(selection: Selection): boolean {\n    if (!(selection instanceof MultipleNodeSelection)) {\n      return false;\n    }\n\n    if (this.nodes.length !== selection.nodes.length) {\n      return false;\n    }\n\n    if (this.from !== selection.from || this.to !== selection.to) {\n      return false;\n    }\n\n    for (let i = 0; i < this.nodes.length; i++) {\n      if (!this.nodes[i].eq(selection.nodes[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  map(doc: Node, mapping: Mappable): Selection {\n    let fromResult = mapping.mapResult(this.from);\n    let toResult = mapping.mapResult(this.to);\n\n    if (toResult.deleted) {\n      return Selection.near(doc.resolve(fromResult.pos));\n    }\n\n    if (fromResult.deleted) {\n      return Selection.near(doc.resolve(toResult.pos));\n    }\n\n    return new MultipleNodeSelection(\n      doc.resolve(fromResult.pos),\n      doc.resolve(toResult.pos)\n    );\n  }\n\n  toJSON(): any {\n    return { type: \"node\", anchor: this.anchor, head: this.head };\n  }\n}\n","import { Editor } from \"@tiptap/core\";\nimport { Node } from \"prosemirror-model\";\nimport { NodeSelection, Plugin, PluginKey, Selection } from \"prosemirror-state\";\nimport * as pv from \"prosemirror-view\";\nimport { EditorView } from \"prosemirror-view\";\nimport styles from \"../../editor.module.css\";\nimport { getBlockInfoFromPos } from \"../Blocks/helpers/getBlockInfoFromPos\";\nimport { SlashMenuPluginKey } from \"../SlashMenu/SlashMenuExtension\";\nimport {\n  BlockSideMenu,\n  BlockSideMenuDynamicParams,\n  BlockSideMenuFactory,\n  BlockSideMenuStaticParams,\n} from \"./BlockSideMenuFactoryTypes\";\nimport { DraggableBlocksOptions } from \"./DraggableBlocksExtension\";\nimport { MultipleNodeSelection } from \"./MultipleNodeSelection\";\nimport { BlockNoteEditor } from \"../../BlockNoteEditor\";\n\nconst serializeForClipboard = (pv as any).__serializeForClipboard;\n// code based on https://github.com/ueberdosis/tiptap/issues/323#issuecomment-506637799\n\nlet dragImageElement: Element | undefined;\n\nfunction getDraggableBlockFromCoords(\n  coords: { left: number; top: number },\n  view: EditorView\n) {\n  if (!view.dom.isConnected) {\n    // view is not connected to the DOM, this can cause posAtCoords to fail\n    // (Cannot read properties of null (reading 'nearestDesc'), https://github.com/TypeCellOS/BlockNote/issues/123)\n    return undefined;\n  }\n\n  let pos = view.posAtCoords(coords);\n  if (!pos) {\n    return undefined;\n  }\n  let node = view.domAtPos(pos.pos).node as HTMLElement;\n\n  if (node === view.dom) {\n    // mouse over root\n    return undefined;\n  }\n\n  while (\n    node &&\n    node.parentNode &&\n    node.parentNode !== view.dom &&\n    !node.hasAttribute?.(\"data-id\")\n  ) {\n    node = node.parentNode as HTMLElement;\n  }\n  if (!node) {\n    return undefined;\n  }\n  return { node, id: node.getAttribute(\"data-id\")! };\n}\n\nfunction blockPositionFromCoords(\n  coords: { left: number; top: number },\n  view: EditorView\n) {\n  let block = getDraggableBlockFromCoords(coords, view);\n\n  if (block && block.node.nodeType === 1) {\n    // TODO: this uses undocumented PM APIs? do we need this / let's add docs?\n    const docView = (view as any).docView;\n    let desc = docView.nearestDesc(block.node, true);\n    if (!desc || desc === docView) {\n      return null;\n    }\n    return desc.posBefore;\n  }\n  return null;\n}\n\nfunction blockPositionsFromSelection(selection: Selection, doc: Node) {\n  // Absolute positions just before the first block spanned by the selection, and just after the last block. Having the\n  // selection start and end just before and just after the target blocks ensures no whitespace/line breaks are left\n  // behind after dragging & dropping them.\n  let beforeFirstBlockPos: number;\n  let afterLastBlockPos: number;\n\n  // Even the user starts dragging blocks but drops them in the same place, the selection will still be moved just\n  // before & just after the blocks spanned by the selection, and therefore doesn't need to change if they try to drag\n  // the same blocks again. If this happens, the anchor & head move out of the block content node they were originally\n  // in. If the anchor should update but the head shouldn't and vice versa, it means the user selection is outside a\n  // block content node, which should never happen.\n  const selectionStartInBlockContent =\n    doc.resolve(selection.from).node().type.spec.group === \"blockContent\";\n  const selectionEndInBlockContent =\n    doc.resolve(selection.to).node().type.spec.group === \"blockContent\";\n\n  // Ensures that entire outermost nodes are selected if the selection spans multiple nesting levels.\n  const minDepth = Math.min(selection.$anchor.depth, selection.$head.depth);\n\n  if (selectionStartInBlockContent && selectionEndInBlockContent) {\n    // Absolute positions at the start of the first block in the selection and at the end of the last block. User\n    // selections will always start and end in block content nodes, but we want the start and end positions of their\n    // parent block nodes, which is why minDepth - 1 is used.\n    const startFirstBlockPos = selection.$from.start(minDepth - 1);\n    const endLastBlockPos = selection.$to.end(minDepth - 1);\n\n    // Shifting start and end positions by one moves them just outside the first and last selected blocks.\n    beforeFirstBlockPos = doc.resolve(startFirstBlockPos - 1).pos;\n    afterLastBlockPos = doc.resolve(endLastBlockPos + 1).pos;\n  } else {\n    beforeFirstBlockPos = selection.from;\n    afterLastBlockPos = selection.to;\n  }\n\n  return { from: beforeFirstBlockPos, to: afterLastBlockPos };\n}\n\nfunction setDragImage(view: EditorView, from: number, to = from) {\n  if (from === to) {\n    // Moves to position to be just after the first (and only) selected block.\n    to += view.state.doc.resolve(from + 1).node().nodeSize;\n  }\n\n  // Parent element is cloned to remove all unselected children without affecting the editor content.\n  const parentClone = view.domAtPos(from).node.cloneNode(true) as Element;\n  const parent = view.domAtPos(from).node as Element;\n\n  const getElementIndex = (parentElement: Element, targetElement: Element) =>\n    Array.prototype.indexOf.call(parentElement.children, targetElement);\n\n  const firstSelectedBlockIndex = getElementIndex(\n    parent,\n    // Expects from position to be just before the first selected block.\n    view.domAtPos(from + 1).node.parentElement!\n  );\n  const lastSelectedBlockIndex = getElementIndex(\n    parent,\n    // Expects to position to be just after the last selected block.\n    view.domAtPos(to - 1).node.parentElement!\n  );\n\n  for (let i = parent.childElementCount - 1; i >= 0; i--) {\n    if (i > lastSelectedBlockIndex || i < firstSelectedBlockIndex) {\n      parentClone.removeChild(parentClone.children[i]);\n    }\n  }\n\n  // dataTransfer.setDragImage(element) only works if element is attached to the DOM.\n  unsetDragImage();\n  dragImageElement = parentClone;\n\n  // TODO: This is hacky, need a better way of assigning classes to the editor so that they can also be applied to the\n  //  drag preview.\n  const classes = view.dom.className.split(\" \");\n  const inheritedClasses = classes\n    .filter(\n      (className) =>\n        !className.includes(\"bn\") &&\n        !className.includes(\"ProseMirror\") &&\n        !className.includes(\"editor\")\n    )\n    .join(\" \");\n\n  dragImageElement.className =\n    dragImageElement.className +\n    \" \" +\n    styles.dragPreview +\n    \" \" +\n    inheritedClasses;\n\n  document.body.appendChild(dragImageElement);\n}\n\nfunction unsetDragImage() {\n  if (dragImageElement !== undefined) {\n    document.body.removeChild(dragImageElement);\n    dragImageElement = undefined;\n  }\n}\n\nfunction dragStart(e: DragEvent, view: EditorView) {\n  if (!e.dataTransfer) {\n    return;\n  }\n\n  const editorBoundingBox = view.dom.getBoundingClientRect();\n\n  let coords = {\n    left: editorBoundingBox.left + editorBoundingBox.width / 2, // take middle of editor\n    top: e.clientY,\n  };\n\n  let pos = blockPositionFromCoords(coords, view);\n  if (pos != null) {\n    const selection = view.state.selection;\n    const doc = view.state.doc;\n\n    const { from, to } = blockPositionsFromSelection(selection, doc);\n\n    const draggedBlockInSelection = from <= pos && pos < to;\n    const multipleBlocksSelected =\n      selection.$anchor.node() !== selection.$head.node() ||\n      selection instanceof MultipleNodeSelection;\n\n    if (draggedBlockInSelection && multipleBlocksSelected) {\n      view.dispatch(\n        view.state.tr.setSelection(MultipleNodeSelection.create(doc, from, to))\n      );\n      setDragImage(view, from, to);\n    } else {\n      view.dispatch(\n        view.state.tr.setSelection(NodeSelection.create(view.state.doc, pos))\n      );\n      setDragImage(view, pos);\n    }\n\n    let slice = view.state.selection.content();\n    let { dom, text } = serializeForClipboard(view, slice);\n\n    e.dataTransfer.clearData();\n    e.dataTransfer.setData(\"text/html\", dom.innerHTML);\n    e.dataTransfer.setData(\"text/plain\", text);\n    e.dataTransfer.effectAllowed = \"move\";\n    e.dataTransfer.setDragImage(dragImageElement!, 0, 0);\n    view.dragging = { slice, move: true };\n  }\n}\n\nexport type BlockMenuViewProps = {\n  tiptapEditor: Editor;\n  editor: BlockNoteEditor;\n  blockMenuFactory: BlockSideMenuFactory;\n  horizontalPosAnchoredAtRoot: boolean;\n};\n\nexport class BlockMenuView {\n  editor: BlockNoteEditor;\n  private ttEditor: Editor;\n\n  // When true, the drag handle with be anchored at the same level as root elements\n  // When false, the drag handle with be just to the left of the element\n  horizontalPosAnchoredAtRoot: boolean;\n\n  horizontalPosAnchor: number;\n\n  blockMenu: BlockSideMenu;\n\n  hoveredBlock: HTMLElement | undefined;\n\n  // Used to check if currently dragged content comes from this editor instance.\n  isDragging = false;\n  menuOpen = false;\n  menuFrozen = false;\n\n  constructor({\n    tiptapEditor,\n    editor,\n    blockMenuFactory,\n    horizontalPosAnchoredAtRoot,\n  }: BlockMenuViewProps) {\n    this.editor = editor;\n    this.ttEditor = tiptapEditor;\n    this.horizontalPosAnchoredAtRoot = horizontalPosAnchoredAtRoot;\n    this.horizontalPosAnchor = (\n      this.ttEditor.view.dom.firstChild! as HTMLElement\n    ).getBoundingClientRect().x;\n\n    this.blockMenu = blockMenuFactory(this.getStaticParams());\n\n    document.body.addEventListener(\"drop\", this.onDrop, true);\n    document.body.addEventListener(\"dragover\", this.onDragOver);\n    this.ttEditor.view.dom.addEventListener(\"dragstart\", this.onDragStart);\n\n    // Shows or updates menu position whenever the cursor moves, if the menu isn't frozen.\n    document.body.addEventListener(\"mousemove\", this.onMouseMove, true);\n\n    // Makes menu scroll with the page.\n    document.addEventListener(\"scroll\", this.onScroll);\n\n    // Hides and unfreezes the menu whenever the user selects the editor with the mouse or presses a key.\n    // TODO: Better integration with suggestions menu and only editor scope?\n    document.body.addEventListener(\"mousedown\", this.onMouseDown, true);\n    document.body.addEventListener(\"keydown\", this.onKeyDown, true);\n  }\n\n  /**\n   * Sets isDragging when dragging text.\n   */\n  onDragStart = () => {\n    this.isDragging = true;\n  };\n\n  /**\n   * If the event is outside the editor contents,\n   * we dispatch a fake event, so that we can still drop the content\n   * when dragging / dropping to the side of the editor\n   */\n  onDrop = (event: DragEvent) => {\n    if ((event as any).synthetic || !this.isDragging) {\n      return;\n    }\n    let pos = this.ttEditor.view.posAtCoords({\n      left: event.clientX,\n      top: event.clientY,\n    });\n\n    this.isDragging = false;\n\n    if (!pos || pos.inside === -1) {\n      const evt = new Event(\"drop\", event) as any;\n      const editorBoundingBox = (\n        this.ttEditor.view.dom.firstChild! as HTMLElement\n      ).getBoundingClientRect();\n      evt.clientX = editorBoundingBox.left + editorBoundingBox.width / 2;\n      evt.clientY = event.clientY;\n      evt.dataTransfer = event.dataTransfer;\n      evt.preventDefault = () => event.preventDefault();\n      evt.synthetic = true; // prevent recursion\n      // console.log(\"dispatch fake drop\");\n      this.ttEditor.view.dom.dispatchEvent(evt);\n    }\n  };\n\n  /**\n   * If the event is outside of the editor contents,\n   * we dispatch a fake event, so that we can still drop the content\n   * when dragging / dropping to the side of the editor\n   */\n  onDragOver = (event: DragEvent) => {\n    if ((event as any).synthetic || !this.isDragging) {\n      return;\n    }\n    let pos = this.ttEditor.view.posAtCoords({\n      left: event.clientX,\n      top: event.clientY,\n    });\n\n    if (!pos || pos.inside === -1) {\n      const evt = new Event(\"dragover\", event) as any;\n      const editorBoundingBox = (\n        this.ttEditor.view.dom.firstChild! as HTMLElement\n      ).getBoundingClientRect();\n      evt.clientX = editorBoundingBox.left + editorBoundingBox.width / 2;\n      evt.clientY = event.clientY;\n      evt.dataTransfer = event.dataTransfer;\n      evt.preventDefault = () => event.preventDefault();\n      evt.synthetic = true; // prevent recursion\n      // console.log(\"dispatch fake dragover\");\n      this.ttEditor.view.dom.dispatchEvent(evt);\n    }\n  };\n\n  onKeyDown = (_event: KeyboardEvent) => {\n    if (this.menuOpen) {\n      this.menuOpen = false;\n      this.blockMenu.hide();\n    }\n\n    this.menuFrozen = false;\n  };\n\n  onMouseDown = (event: MouseEvent) => {\n    if (this.blockMenu.element?.contains(event.target as HTMLElement)) {\n      return;\n    }\n\n    if (this.menuOpen) {\n      this.menuOpen = false;\n      this.blockMenu.hide();\n    }\n\n    this.menuFrozen = false;\n  };\n\n  onMouseMove = (event: MouseEvent) => {\n    if (this.menuFrozen) {\n      return;\n    }\n\n    // Editor itself may have padding or other styling which affects size/position, so we get the boundingRect of\n    // the first child (i.e. the blockGroup that wraps all blocks in the editor) for a more accurate bounding box.\n    const editorBoundingBox = (\n      this.ttEditor.view.dom.firstChild! as HTMLElement\n    ).getBoundingClientRect();\n\n    this.horizontalPosAnchor = editorBoundingBox.x;\n\n    // Gets block at mouse cursor's vertical position.\n    const coords = {\n      left: editorBoundingBox.left + editorBoundingBox.width / 2, // take middle of editor\n      top: event.clientY,\n    };\n    const block = getDraggableBlockFromCoords(coords, this.ttEditor.view);\n\n    // Closes the menu if the mouse cursor is beyond the editor vertically.\n    if (!block || !this.editor.isEditable) {\n      if (this.menuOpen) {\n        this.menuOpen = false;\n        this.blockMenu.hide();\n      }\n\n      return;\n    }\n\n    // Doesn't update if the menu is already open and the mouse cursor is still hovering the same block.\n    if (\n      this.menuOpen &&\n      this.hoveredBlock?.hasAttribute(\"data-id\") &&\n      this.hoveredBlock?.getAttribute(\"data-id\") === block.id\n    ) {\n      return;\n    }\n\n    this.hoveredBlock = block.node;\n\n    // Gets the block's content node, which lets to ignore child blocks when determining the block menu's position.\n    const blockContent = block.node.firstChild as HTMLElement;\n\n    if (!blockContent) {\n      return;\n    }\n\n    // Shows or updates elements.\n    if (this.editor.isEditable) {\n      if (!this.menuOpen) {\n        this.menuOpen = true;\n        this.blockMenu.render(this.getDynamicParams(), true);\n      } else {\n        this.blockMenu.render(this.getDynamicParams(), false);\n      }\n    }\n  };\n\n  onScroll = () => {\n    if (this.menuOpen) {\n      this.blockMenu.render(this.getDynamicParams(), false);\n    }\n  };\n\n  destroy() {\n    if (this.menuOpen) {\n      this.menuOpen = false;\n      this.blockMenu.hide();\n    }\n    document.body.removeEventListener(\"mousemove\", this.onMouseMove);\n    document.body.removeEventListener(\"dragover\", this.onDragOver);\n    this.ttEditor.view.dom.removeEventListener(\"dragstart\", this.onDragStart);\n    document.body.removeEventListener(\"drop\", this.onDrop);\n    document.body.removeEventListener(\"mousedown\", this.onMouseDown);\n    document.removeEventListener(\"scroll\", this.onScroll);\n    document.body.removeEventListener(\"keydown\", this.onKeyDown);\n  }\n\n  addBlock() {\n    this.menuOpen = false;\n    this.menuFrozen = true;\n    this.blockMenu.hide();\n\n    const blockContent = this.hoveredBlock!.firstChild! as HTMLElement;\n    const blockContentBoundingBox = blockContent.getBoundingClientRect();\n\n    const pos = this.ttEditor.view.posAtCoords({\n      left: blockContentBoundingBox.left + blockContentBoundingBox.width / 2,\n      top: blockContentBoundingBox.top + blockContentBoundingBox.height / 2,\n    });\n    if (!pos) {\n      return;\n    }\n\n    const blockInfo = getBlockInfoFromPos(this.ttEditor.state.doc, pos.pos);\n    if (blockInfo === undefined) {\n      return;\n    }\n\n    const { contentNode, endPos } = blockInfo;\n\n    // Creates a new block if current one is not empty for the suggestion menu to open in.\n    if (contentNode.textContent.length !== 0) {\n      const newBlockInsertionPos = endPos + 1;\n      const newBlockContentPos = newBlockInsertionPos + 2;\n\n      this.ttEditor\n        .chain()\n        .BNCreateBlock(newBlockInsertionPos)\n        .BNUpdateBlock(newBlockContentPos, { type: \"paragraph\", props: {} })\n        .setTextSelection(newBlockContentPos)\n        .run();\n    } else {\n      this.ttEditor.commands.setTextSelection(endPos);\n    }\n\n    // Focuses and activates the suggestion menu.\n    this.ttEditor.view.focus();\n    this.ttEditor.view.dispatch(\n      this.ttEditor.view.state.tr.scrollIntoView().setMeta(SlashMenuPluginKey, {\n        // TODO import suggestion plugin key\n        activate: true,\n        type: \"drag\",\n      })\n    );\n  }\n\n  getStaticParams(): BlockSideMenuStaticParams {\n    return {\n      editor: this.editor,\n      addBlock: () => this.addBlock(),\n      blockDragStart: (event: DragEvent) => {\n        // Sets isDragging when dragging blocks.\n        this.isDragging = true;\n        dragStart(event, this.ttEditor.view);\n      },\n      blockDragEnd: () => unsetDragImage(),\n      freezeMenu: () => {\n        this.menuFrozen = true;\n      },\n      unfreezeMenu: () => {\n        this.menuFrozen = false;\n      },\n    };\n  }\n\n  getDynamicParams(): BlockSideMenuDynamicParams {\n    const blockContent = this.hoveredBlock!.firstChild! as HTMLElement;\n    const blockContentBoundingBox = blockContent.getBoundingClientRect();\n\n    return {\n      block: this.editor.getBlock(this.hoveredBlock!.getAttribute(\"data-id\")!)!,\n      referenceRect: new DOMRect(\n        this.horizontalPosAnchoredAtRoot\n          ? this.horizontalPosAnchor\n          : blockContentBoundingBox.x,\n        blockContentBoundingBox.y,\n        blockContentBoundingBox.width,\n        blockContentBoundingBox.height\n      ),\n    };\n  }\n}\n\nexport const createDraggableBlocksPlugin = (\n  options: DraggableBlocksOptions\n) => {\n  return new Plugin({\n    key: new PluginKey(\"DraggableBlocksPlugin\"),\n    view: () =>\n      new BlockMenuView({\n        tiptapEditor: options.tiptapEditor,\n        editor: options.editor,\n        blockMenuFactory: options.blockSideMenuFactory,\n        horizontalPosAnchoredAtRoot: true,\n      }),\n  });\n};\n","import { Editor, Extension } from \"@tiptap/core\";\nimport { BlockSideMenuFactory } from \"./BlockSideMenuFactoryTypes\";\nimport { createDraggableBlocksPlugin } from \"./DraggableBlocksPlugin\";\nimport { BlockNoteEditor } from \"../../BlockNoteEditor\";\n\nexport type DraggableBlocksOptions = {\n  tiptapEditor: Editor;\n  editor: BlockNoteEditor;\n  blockSideMenuFactory: BlockSideMenuFactory;\n};\n\n/**\n * This extension adds a menu to the side of blocks which features various BlockNote functions such as adding and\n * removing blocks. More importantly, it adds a drag handle which allows the user to drag and drop blocks.\n *\n * code based on https://github.com/ueberdosis/tiptap/issues/323#issuecomment-506637799\n */\nexport const DraggableBlocksExtension =\n  Extension.create<DraggableBlocksOptions>({\n    name: \"DraggableBlocksExtension\",\n    priority: 1000, // Need to be high, in order to hide menu when typing slash\n    addProseMirrorPlugins() {\n      if (!this.options.blockSideMenuFactory) {\n        throw new Error(\n          \"UI Element factory not defined for DraggableBlocksExtension\"\n        );\n      }\n      return [\n        createDraggableBlocksPlugin({\n          tiptapEditor: this.editor,\n          editor: this.options.editor,\n          blockSideMenuFactory: this.options.blockSideMenuFactory,\n        }),\n      ];\n    },\n  });\n","import {\n  Editor,\n  isNodeSelection,\n  isTextSelection,\n  posToDOMRect,\n} from \"@tiptap/core\";\nimport { EditorState, Plugin, PluginKey } from \"prosemirror-state\";\nimport { EditorView } from \"prosemirror-view\";\nimport { BlockNoteEditor } from \"../..\";\nimport {\n  FormattingToolbar,\n  FormattingToolbarDynamicParams,\n  FormattingToolbarFactory,\n  FormattingToolbarStaticParams,\n} from \"./FormattingToolbarFactoryTypes\";\n\n// Same as TipTap bubblemenu plugin, but with these changes:\n// https://github.com/ueberdosis/tiptap/pull/2596/files\nexport interface FormattingToolbarPluginProps {\n  pluginKey: PluginKey;\n  tiptapEditor: Editor;\n  editor: BlockNoteEditor;\n  formattingToolbarFactory: FormattingToolbarFactory;\n  shouldShow?:\n    | ((props: {\n        editor: BlockNoteEditor;\n        view: EditorView;\n        state: EditorState;\n        oldState?: EditorState;\n        from: number;\n        to: number;\n      }) => boolean)\n    | null;\n}\n\nexport type FormattingToolbarViewProps = FormattingToolbarPluginProps & {\n  view: EditorView;\n};\n\nexport class FormattingToolbarView {\n  public editor: BlockNoteEditor;\n  private ttEditor: Editor;\n\n  public view: EditorView;\n\n  public formattingToolbar: FormattingToolbar;\n\n  public preventHide = false;\n\n  public preventShow = false;\n\n  public toolbarIsOpen = false;\n\n  public prevWasEditable: boolean | null = null;\n\n  public shouldShow: Exclude<FormattingToolbarPluginProps[\"shouldShow\"], null> =\n    ({ view, state, from, to }) => {\n      const { doc, selection } = state;\n      const { empty } = selection;\n\n      // Sometime check for `empty` is not enough.\n      // Doubleclick an empty paragraph returns a node size of 2.\n      // So we check also for an empty text size.\n      const isEmptyTextBlock =\n        !doc.textBetween(from, to).length && isTextSelection(state.selection);\n\n      return !(!view.hasFocus() || empty || isEmptyTextBlock);\n    };\n\n  constructor({\n    editor,\n    tiptapEditor,\n    formattingToolbarFactory,\n    view,\n    shouldShow,\n  }: FormattingToolbarViewProps) {\n    this.editor = editor;\n    this.ttEditor = tiptapEditor;\n    this.view = view;\n\n    this.formattingToolbar = formattingToolbarFactory(this.getStaticParams());\n\n    if (shouldShow) {\n      this.shouldShow = shouldShow;\n    }\n\n    this.view.dom.addEventListener(\"mousedown\", this.viewMousedownHandler);\n    this.view.dom.addEventListener(\"mouseup\", this.viewMouseupHandler);\n    this.view.dom.addEventListener(\"dragstart\", this.dragstartHandler);\n\n    this.ttEditor.on(\"focus\", this.focusHandler);\n    this.ttEditor.on(\"blur\", this.blurHandler);\n    \n    document.addEventListener(\"scroll\", this.scrollHandler);\n  }\n\n  viewMousedownHandler = () => {\n    this.preventShow = true;\n  };\n\n  viewMouseupHandler = () => {\n    this.preventShow = false;\n    setTimeout(() => this.update(this.ttEditor.view));\n  };\n\n  dragstartHandler = () => {\n    this.formattingToolbar.hide();\n    this.toolbarIsOpen = false;\n  };\n\n  focusHandler = () => {\n    // we use `setTimeout` to make sure `selection` is already updated\n    setTimeout(() => this.update(this.ttEditor.view));\n  };\n\n  blurHandler = ({ event }: { event: FocusEvent }) => {\n    if (this.preventHide) {\n      this.preventHide = false;\n\n      return;\n    }\n\n    if (\n      event?.relatedTarget &&\n      this.formattingToolbar.element?.parentNode?.contains(\n        event.relatedTarget as Node\n      )\n    ) {\n      return;\n    }\n\n    if (this.toolbarIsOpen) {\n      this.formattingToolbar.hide();\n      this.toolbarIsOpen = false;\n    }\n  };\n\n  scrollHandler = () => {\n    if (this.toolbarIsOpen) {\n      this.formattingToolbar.render(this.getDynamicParams(), false);\n    }\n  };\n\n  update(view: EditorView, oldState?: EditorState) {\n    const { state, composing } = view;\n    const { doc, selection } = state;\n    const isSame =\n      oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);\n\n    if (\n      (this.prevWasEditable === null ||\n        this.prevWasEditable === this.editor.isEditable) &&\n      (composing || isSame)\n    ) {\n      return;\n    }\n\n    this.prevWasEditable = this.editor.isEditable;\n\n    // support for CellSelections\n    const { ranges } = selection;\n    const from = Math.min(...ranges.map((range) => range.$from.pos));\n    const to = Math.max(...ranges.map((range) => range.$to.pos));\n\n    const shouldShow = this.shouldShow?.({\n      editor: this.editor,\n      view,\n      state,\n      oldState,\n      from,\n      to,\n    });\n\n    // Checks if menu should be shown.\n    if (\n      this.editor.isEditable &&\n      !this.toolbarIsOpen &&\n      !this.preventShow &&\n      (shouldShow || this.preventHide)\n    ) {\n      this.formattingToolbar.render(this.getDynamicParams(), true);\n      this.toolbarIsOpen = true;\n\n      // TODO: Is this necessary? Also for other menu plugins.\n      // Listener stops focus moving to the menu on click.\n      this.formattingToolbar.element!.addEventListener(\"mousedown\", (event) =>\n        event.preventDefault()\n      );\n\n      return;\n    }\n\n    // Checks if menu should be updated.\n    if (\n      this.toolbarIsOpen &&\n      !this.preventShow &&\n      (shouldShow || this.preventHide)\n    ) {\n      this.formattingToolbar.render(this.getDynamicParams(), false);\n      return;\n    }\n\n    // Checks if menu should be hidden.\n    if (\n      this.toolbarIsOpen &&\n      !this.preventHide &&\n      (!shouldShow || this.preventShow || !this.editor.isEditable)\n    ) {\n      this.formattingToolbar.hide();\n      this.toolbarIsOpen = false;\n\n      // Listener stops focus moving to the menu on click.\n      this.formattingToolbar.element!.removeEventListener(\n        \"mousedown\",\n        (event) => event.preventDefault()\n      );\n\n      return;\n    }\n  }\n\n  destroy() {\n    this.view.dom.removeEventListener(\"mousedown\", this.viewMousedownHandler);\n    this.view.dom.removeEventListener(\"mouseup\", this.viewMouseupHandler);\n    this.view.dom.removeEventListener(\"dragstart\", this.dragstartHandler);\n\n    this.ttEditor.off(\"focus\", this.focusHandler);\n    this.ttEditor.off(\"blur\", this.blurHandler);\n\n    document.removeEventListener(\"scroll\", this.scrollHandler);\n  }\n\n  getSelectionBoundingBox() {\n    const { state } = this.ttEditor.view;\n    const { selection } = state;\n\n    // support for CellSelections\n    const { ranges } = selection;\n    const from = Math.min(...ranges.map((range) => range.$from.pos));\n    const to = Math.max(...ranges.map((range) => range.$to.pos));\n\n    if (isNodeSelection(selection)) {\n      const node = this.ttEditor.view.nodeDOM(from) as HTMLElement;\n\n      if (node) {\n        return node.getBoundingClientRect();\n      }\n    }\n\n    return posToDOMRect(this.ttEditor.view, from, to);\n  }\n\n  getStaticParams(): FormattingToolbarStaticParams {\n    return {\n      editor: this.editor,\n    };\n  }\n\n  getDynamicParams(): FormattingToolbarDynamicParams {\n    return {\n      referenceRect: this.getSelectionBoundingBox(),\n    };\n  }\n}\n\nexport const createFormattingToolbarPlugin = (\n  options: FormattingToolbarPluginProps\n) => {\n  return new Plugin({\n    key: new PluginKey(\"FormattingToolbarPlugin\"),\n    view: (view) => new FormattingToolbarView({ view, ...options }),\n  });\n};\n","import { Extension } from \"@tiptap/core\";\nimport { PluginKey } from \"prosemirror-state\";\nimport { BlockNoteEditor } from \"../..\";\nimport { FormattingToolbarFactory } from \"./FormattingToolbarFactoryTypes\";\nimport { createFormattingToolbarPlugin } from \"./FormattingToolbarPlugin\";\n\n/**\n * The menu that is displayed when selecting a piece of text.\n */\nexport const FormattingToolbarExtension = Extension.create<{\n  formattingToolbarFactory: FormattingToolbarFactory;\n  editor: BlockNoteEditor;\n}>({\n  name: \"FormattingToolbarExtension\",\n\n  addProseMirrorPlugins() {\n    if (!this.options.formattingToolbarFactory || !this.options.editor) {\n      throw new Error(\n        \"required args not defined for FormattingToolbarExtension\"\n      );\n    }\n\n    return [\n      createFormattingToolbarPlugin({\n        tiptapEditor: this.editor,\n        editor: this.options.editor,\n        formattingToolbarFactory: this.options.formattingToolbarFactory,\n        pluginKey: new PluginKey(\"FormattingToolbarPlugin\"),\n      }),\n    ];\n  },\n});\n","import { Editor, getMarkRange, posToDOMRect, Range } from \"@tiptap/core\";\nimport { Mark } from \"prosemirror-model\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\nimport {\n  HyperlinkToolbar,\n  HyperlinkToolbarDynamicParams,\n  HyperlinkToolbarFactory,\n  HyperlinkToolbarStaticParams,\n} from \"./HyperlinkToolbarFactoryTypes\";\nconst PLUGIN_KEY = new PluginKey(\"HyperlinkToolbarPlugin\");\n\nexport type HyperlinkToolbarPluginProps = {\n  hyperlinkToolbarFactory: HyperlinkToolbarFactory;\n};\n\nexport type HyperlinkToolbarViewProps = {\n  editor: Editor;\n  hyperlinkToolbarFactory: HyperlinkToolbarFactory;\n};\n\nclass HyperlinkToolbarView {\n  editor: Editor;\n\n  hyperlinkToolbar: HyperlinkToolbar;\n\n  menuUpdateTimer: NodeJS.Timeout | undefined;\n  startMenuUpdateTimer: () => void;\n  stopMenuUpdateTimer: () => void;\n\n  mouseHoveredHyperlinkMark: Mark | undefined;\n  mouseHoveredHyperlinkMarkRange: Range | undefined;\n\n  keyboardHoveredHyperlinkMark: Mark | undefined;\n  keyboardHoveredHyperlinkMarkRange: Range | undefined;\n\n  hyperlinkMark: Mark | undefined;\n  hyperlinkMarkRange: Range | undefined;\n\n  constructor({ editor, hyperlinkToolbarFactory }: HyperlinkToolbarViewProps) {\n    this.editor = editor;\n\n    this.hyperlinkToolbar = hyperlinkToolbarFactory(this.getStaticParams());\n\n    this.startMenuUpdateTimer = () => {\n      this.menuUpdateTimer = setTimeout(() => {\n        this.update();\n      }, 250);\n    };\n\n    this.stopMenuUpdateTimer = () => {\n      if (this.menuUpdateTimer) {\n        clearTimeout(this.menuUpdateTimer);\n        this.menuUpdateTimer = undefined;\n      }\n\n      return false;\n    };\n\n    this.editor.view.dom.addEventListener(\"mouseover\", this.mouseOverHandler);\n    document.addEventListener(\"scroll\", this.scrollHandler);\n  }\n\n  mouseOverHandler = (event: MouseEvent) => {\n    // Resets the hyperlink mark currently hovered by the mouse cursor.\n    this.mouseHoveredHyperlinkMark = undefined;\n    this.mouseHoveredHyperlinkMarkRange = undefined;\n\n    this.stopMenuUpdateTimer();\n\n    if (\n      event.target instanceof HTMLAnchorElement &&\n      event.target.nodeName === \"A\"\n    ) {\n      // Finds link mark at the hovered element's position to update mouseHoveredHyperlinkMark and\n      // mouseHoveredHyperlinkMarkRange.\n      const hoveredHyperlinkElement = event.target;\n      const posInHoveredHyperlinkMark =\n        this.editor.view.posAtDOM(hoveredHyperlinkElement, 0) + 1;\n      const resolvedPosInHoveredHyperlinkMark = this.editor.state.doc.resolve(\n        posInHoveredHyperlinkMark\n      );\n      const marksAtPos = resolvedPosInHoveredHyperlinkMark.marks();\n\n      for (const mark of marksAtPos) {\n        if (mark.type.name === this.editor.schema.mark(\"link\").type.name) {\n          this.mouseHoveredHyperlinkMark = mark;\n          this.mouseHoveredHyperlinkMarkRange =\n            getMarkRange(\n              resolvedPosInHoveredHyperlinkMark,\n              mark.type,\n              mark.attrs\n            ) || undefined;\n\n          break;\n        }\n      }\n    }\n\n    this.startMenuUpdateTimer();\n\n    return false;\n  };\n\n  scrollHandler = () => {\n    if (this.hyperlinkMark !== undefined) {\n      this.hyperlinkToolbar.render(this.getDynamicParams(), false);\n    }\n  };\n\n  update() {\n    if (!this.editor.view.hasFocus()) {\n      return;\n    }\n\n    // Saves the currently hovered hyperlink mark before it's updated.\n    const prevHyperlinkMark = this.hyperlinkMark;\n\n    // Resets the currently hovered hyperlink mark.\n    this.hyperlinkMark = undefined;\n    this.hyperlinkMarkRange = undefined;\n\n    // Resets the hyperlink mark currently hovered by the keyboard cursor.\n    this.keyboardHoveredHyperlinkMark = undefined;\n    this.keyboardHoveredHyperlinkMarkRange = undefined;\n\n    // Finds link mark at the editor selection's position to update keyboardHoveredHyperlinkMark and\n    // keyboardHoveredHyperlinkMarkRange.\n    if (this.editor.state.selection.empty) {\n      const marksAtPos = this.editor.state.selection.$from.marks();\n\n      for (const mark of marksAtPos) {\n        if (mark.type.name === this.editor.schema.mark(\"link\").type.name) {\n          this.keyboardHoveredHyperlinkMark = mark;\n          this.keyboardHoveredHyperlinkMarkRange =\n            getMarkRange(\n              this.editor.state.selection.$from,\n              mark.type,\n              mark.attrs\n            ) || undefined;\n\n          break;\n        }\n      }\n    }\n\n    if (this.mouseHoveredHyperlinkMark) {\n      this.hyperlinkMark = this.mouseHoveredHyperlinkMark;\n      this.hyperlinkMarkRange = this.mouseHoveredHyperlinkMarkRange;\n    }\n\n    // Keyboard cursor position takes precedence over mouse hovered hyperlink.\n    if (this.keyboardHoveredHyperlinkMark) {\n      this.hyperlinkMark = this.keyboardHoveredHyperlinkMark;\n      this.hyperlinkMarkRange = this.keyboardHoveredHyperlinkMarkRange;\n    }\n\n    if (this.hyperlinkMark && this.editor.isEditable) {\n      this.getDynamicParams();\n\n      // Shows menu.\n      if (!prevHyperlinkMark) {\n        this.hyperlinkToolbar.render(this.getDynamicParams(), true);\n\n        this.hyperlinkToolbar.element?.addEventListener(\n          \"mouseleave\",\n          this.startMenuUpdateTimer\n        );\n        this.hyperlinkToolbar.element?.addEventListener(\n          \"mouseenter\",\n          this.stopMenuUpdateTimer\n        );\n\n        return;\n      }\n\n      // Updates menu.\n      this.hyperlinkToolbar.render(this.getDynamicParams(), false);\n\n      return;\n    }\n\n    // Hides menu.\n    if (prevHyperlinkMark && (!this.hyperlinkMark || !this.editor.isEditable)) {\n      this.hyperlinkToolbar.element?.removeEventListener(\n        \"mouseleave\",\n        this.startMenuUpdateTimer\n      );\n      this.hyperlinkToolbar.element?.removeEventListener(\n        \"mouseenter\",\n        this.stopMenuUpdateTimer\n      );\n\n      this.hyperlinkToolbar.hide();\n\n      return;\n    }\n  }\n\n  destroy() {\n    this.editor.view.dom.removeEventListener(\n      \"mouseover\",\n      this.mouseOverHandler\n    );\n    document.removeEventListener(\"scroll\", this.scrollHandler);\n  }\n\n  getStaticParams(): HyperlinkToolbarStaticParams {\n    return {\n      editHyperlink: (url: string, text: string) => {\n        const tr = this.editor.view.state.tr.insertText(\n          text,\n          this.hyperlinkMarkRange!.from,\n          this.hyperlinkMarkRange!.to\n        );\n        tr.addMark(\n          this.hyperlinkMarkRange!.from,\n          this.hyperlinkMarkRange!.from + text.length,\n          this.editor.schema.mark(\"link\", { href: url })\n        );\n        this.editor.view.dispatch(tr);\n        this.editor.view.focus();\n\n        this.hyperlinkToolbar.hide();\n      },\n      deleteHyperlink: () => {\n        this.editor.view.dispatch(\n          this.editor.view.state.tr\n            .removeMark(\n              this.hyperlinkMarkRange!.from,\n              this.hyperlinkMarkRange!.to,\n              this.hyperlinkMark!.type\n            )\n            .setMeta(\"preventAutolink\", true)\n        );\n        this.editor.view.focus();\n\n        this.hyperlinkToolbar.hide();\n      },\n    };\n  }\n\n  getDynamicParams(): HyperlinkToolbarDynamicParams {\n    return {\n      url: this.hyperlinkMark!.attrs.href,\n      text: this.editor.view.state.doc.textBetween(\n        this.hyperlinkMarkRange!.from,\n        this.hyperlinkMarkRange!.to\n      ),\n      referenceRect: posToDOMRect(\n        this.editor.view,\n        this.hyperlinkMarkRange!.from,\n        this.hyperlinkMarkRange!.to\n      ),\n    };\n  }\n}\n\nexport const createHyperlinkToolbarPlugin = (\n  editor: Editor,\n  options: HyperlinkToolbarPluginProps\n) => {\n  return new Plugin({\n    key: PLUGIN_KEY,\n    view: () =>\n      new HyperlinkToolbarView({\n        editor: editor,\n        hyperlinkToolbarFactory: options.hyperlinkToolbarFactory,\n      }),\n  });\n};\n","import { Link } from \"@tiptap/extension-link\";\nimport {\n  createHyperlinkToolbarPlugin,\n  HyperlinkToolbarPluginProps,\n} from \"./HyperlinkToolbarPlugin\";\n\n/**\n * This custom link includes a special menu for editing/deleting/opening the link.\n * The menu will be triggered by hovering over the link with the mouse,\n * or by moving the cursor inside the link text\n */\nconst Hyperlink = Link.extend<HyperlinkToolbarPluginProps>({\n  priority: 500,\n  addProseMirrorPlugins() {\n    if (!this.options.hyperlinkToolbarFactory) {\n      throw new Error(\"UI Element factory not defined for HyperlinkMark\");\n    }\n\n    return [\n      ...(this.parent?.() || []),\n      createHyperlinkToolbarPlugin(this.editor, {\n        hyperlinkToolbarFactory: this.options.hyperlinkToolbarFactory,\n      }),\n    ];\n  },\n});\n\nexport default Hyperlink;\n","import { Editor, Extension } from \"@tiptap/core\";\nimport { Node as ProsemirrorNode } from \"prosemirror-model\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\nimport { SlashMenuPluginKey } from \"../SlashMenu/SlashMenuExtension\";\n\nconst PLUGIN_KEY = new PluginKey(`blocknote-placeholder`);\n\n/**\n * This is a modified version of the tiptap\n * placeholder plugin, that also sets hasAnchorClass\n *\n * It does not set a data-placeholder (text is currently done in css)\n *\n */\nexport interface PlaceholderOptions {\n  emptyEditorClass: string;\n  emptyNodeClass: string;\n  isFilterClass: string;\n  hasAnchorClass: string;\n  placeholder:\n    | ((PlaceholderProps: {\n        editor: Editor;\n        node: ProsemirrorNode;\n        pos: number;\n        hasAnchor: boolean;\n      }) => string)\n    | string;\n  showOnlyWhenEditable: boolean;\n  showOnlyCurrent: boolean;\n  includeChildren: boolean;\n}\n\nexport const Placeholder = Extension.create<PlaceholderOptions>({\n  name: \"placeholder\",\n\n  addOptions() {\n    return {\n      emptyEditorClass: \"is-editor-empty\",\n      emptyNodeClass: \"is-empty\",\n      isFilterClass: \"is-filter\",\n      hasAnchorClass: \"has-anchor\",\n      placeholder: \"Write something …\",\n      showOnlyWhenEditable: true,\n      showOnlyCurrent: true,\n      includeChildren: false,\n    };\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: PLUGIN_KEY,\n        props: {\n          decorations: (state) => {\n            const { doc, selection } = state;\n            // Get state of slash menu\n            const menuState = SlashMenuPluginKey.getState(state);\n            const active =\n              this.editor.isEditable || !this.options.showOnlyWhenEditable;\n            const { anchor } = selection;\n            const decorations: Decoration[] = [];\n\n            if (!active) {\n              return;\n            }\n\n            doc.descendants((node, pos) => {\n              const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;\n              const isEmpty = !node.isLeaf && !node.childCount;\n\n              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {\n                const classes = [this.options.emptyNodeClass];\n\n                if (this.editor.isEmpty) {\n                  classes.push(this.options.emptyEditorClass);\n                }\n\n                if (hasAnchor) {\n                  classes.push(this.options.hasAnchorClass);\n                }\n\n                // If slash menu is of drag type and active, show the filter placeholder\n                if (menuState?.triggerCharacter === \"\" && menuState?.active) {\n                  classes.push(this.options.isFilterClass);\n                }\n                // using widget, didn't work (caret position bug)\n                // const decoration = Decoration.widget(\n                //   pos + 1,\n                //   () => {\n                //     const el = document.createElement(\"span\");\n                //     el.innerText = \"hello\";\n                //     return el;\n                //   },\n                //   { side: 0 }\n\n                // Code that sets variables / classes\n                // const ph =\n                //   typeof this.options.placeholder === \"function\"\n                //     ? this.options.placeholder({\n                //         editor: this.editor,\n                //         node,\n                //         pos,\n                //         hasAnchor,\n                //       })\n                //     : this.options.placeholder;\n                // const decoration = Decoration.node(pos, pos + node.nodeSize, {\n                //   class: classes.join(\" \"),\n                //   style: `--placeholder:'${ph.replaceAll(\"'\", \"\\\\'\")}';`,\n                //   \"data-placeholder\": ph,\n                // });\n\n                // Latest version, only set isEmpty and hasAnchor, rest is done via CSS\n\n                const decoration = Decoration.node(pos, pos + node.nodeSize, {\n                  class: classes.join(\" \"),\n                });\n                decorations.push(decoration);\n              }\n\n              return this.options.includeChildren;\n            });\n\n            return DecorationSet.create(doc, decorations);\n          },\n        },\n      }),\n    ];\n  },\n});\n","/**\n * A generic interface used in all suggestion menus (slash menu, mentions, etc)\n */\nexport class SuggestionItem {\n  constructor(public name: string, public match: (query: string) => boolean) {}\n}\n","import { SuggestionItem } from \"../../shared/plugins/suggestion/SuggestionItem\";\nimport { BlockNoteEditor } from \"../../BlockNoteEditor\";\n\n/**\n * A class that defines a slash command (/<command>).\n *\n * (Not to be confused with ProseMirror commands nor TipTap commands.)\n */\nexport class BaseSlashMenuItem extends SuggestionItem {\n  /**\n   * Constructs a new slash-command.\n   *\n   * @param name The name of the command\n   * @param execute The callback for creating a new node\n   * @param aliases Aliases for this command\n   */\n  constructor(\n    public readonly name: string,\n    public readonly execute: (editor: BlockNoteEditor) => void,\n    public readonly aliases: string[] = []\n  ) {\n    super(name, (query: string): boolean => {\n      return (\n        this.name.toLowerCase().startsWith(query.toLowerCase()) ||\n        this.aliases.filter((alias) =>\n          alias.toLowerCase().startsWith(query.toLowerCase())\n        ).length !== 0\n      );\n    });\n  }\n}\n","import { BaseSlashMenuItem } from \"./BaseSlashMenuItem\";\nimport { PartialBlock } from \"../Blocks/api/blockTypes\";\nimport { BlockNoteEditor } from \"../../BlockNoteEditor\";\n\nfunction insertOrUpdateBlock(editor: BlockNoteEditor, block: PartialBlock) {\n  const currentBlock = editor.getTextCursorPosition().block;\n\n  if (\n    (currentBlock.content.length === 1 &&\n      currentBlock.content[0].type === \"text\" &&\n      currentBlock.content[0].text === \"/\") ||\n    currentBlock.content.length === 0\n  ) {\n    editor.updateBlock(currentBlock, block);\n  } else {\n    editor.insertBlocks([block], currentBlock, \"after\");\n    editor.setTextCursorPosition(editor.getTextCursorPosition().nextBlock!);\n  }\n}\n\n/**\n * An array containing commands for creating all default blocks.\n */\nexport const defaultSlashMenuItems: BaseSlashMenuItem[] = [\n  // Command for creating a level 1 heading\n  new BaseSlashMenuItem(\n    \"Heading\",\n    (editor) =>\n      insertOrUpdateBlock(editor, {\n        type: \"heading\",\n        props: { level: \"1\" },\n      }),\n    [\"h\", \"heading1\", \"h1\"]\n  ),\n\n  // Command for creating a level 2 heading\n  new BaseSlashMenuItem(\n    \"Heading 2\",\n    (editor) =>\n      insertOrUpdateBlock(editor, {\n        type: \"heading\",\n        props: { level: \"2\" },\n      }),\n    [\"h2\", \"heading2\", \"subheading\"]\n  ),\n\n  // Command for creating a level 3 heading\n  new BaseSlashMenuItem(\n    \"Heading 3\",\n    (editor) =>\n      insertOrUpdateBlock(editor, {\n        type: \"heading\",\n        props: { level: \"3\" },\n      }),\n    [\"h3\", \"heading3\", \"subheading\"]\n  ),\n\n  // Command for creating an ordered list\n  new BaseSlashMenuItem(\n    \"Numbered List\",\n    (editor) =>\n      insertOrUpdateBlock(editor, {\n        type: \"numberedListItem\",\n      }),\n    [\"li\", \"list\", \"numberedlist\", \"numbered list\"]\n  ),\n\n  // Command for creating a bullet list\n  new BaseSlashMenuItem(\n    \"Bullet List\",\n    (editor) =>\n      insertOrUpdateBlock(editor, {\n        type: \"bulletListItem\",\n      }),\n    [\"ul\", \"list\", \"bulletlist\", \"bullet list\"]\n  ),\n\n  // Command for creating a paragraph (pretty useless)\n  new BaseSlashMenuItem(\n    \"Paragraph\",\n    (editor) =>\n      insertOrUpdateBlock(editor, {\n        type: \"paragraph\",\n      }),\n    [\"p\"]\n  ),\n\n  //     replaceRangeWithNode(editor, range, node);\n\n  //     return true;\n  //   },\n  //   [\"ol\", \"orderedlist\"],\n  //   OrderedListIcon,\n  //   \"Used to display an ordered (enumerated) list item\"\n  // ),\n\n  // Command for creating a blockquote\n  // blockquote: new SlashCommand(\n  //   \"Block Quote\",\n  //   CommandGroup.BASIC_BLOCKS,\n  //   (editor, range) => {\n  //     const paragraph = editor.schema.node(\"paragraph\");\n  //     const node = editor.schema.node(\n  //       \"blockquote\",\n  //       { \"block-id\": uniqueId.generate() },\n  //       paragraph\n  //     );\n\n  //     replaceRangeWithNode(editor, range, node);\n\n  //     return true;\n  //   },\n  //   [\"quote\", \"blockquote\"],\n  //   QuoteIcon,\n  //   \"Used to make a quote stand out\",\n  //   \"Ctrl+Shift+B\"\n  // ),\n\n  // Command for creating a horizontal rule\n  // horizontalRule: new SlashCommand(\n  //   \"Horizontal Rule\",\n  //   CommandGroup.BASIC_BLOCKS,\n  //   (editor, range) => {\n  //     const node = editor.schema.node(\"horizontalRule\", {\n  //       \"block-id\": uniqueId.generate(),\n  //     });\n\n  //     // insert horizontal rule, create a new block after the horizontal rule if applicable\n  //     // and put the cursor in the block after the horizontal rule.\n  //     editor\n  //       .chain()\n  //       .focus()\n  //       .replaceRangeAndUpdateSelection(range, node)\n  //       .command(({ tr, dispatch }) => {\n  //         if (dispatch) {\n  //           // the node immediately after the cursor\n  //           const nodeAfter = tr.selection.$to.nodeAfter;\n\n  //           // the position of the cursor\n  //           const cursorPos = tr.selection.$to.pos;\n\n  //           // check if there is no node after the cursor (end of document)\n  //           if (!nodeAfter) {\n  //             // create a new block of the default type (probably paragraph) after the cursor\n  //             const { parent } = tr.selection.$to;\n  //             const node = parent.type.contentMatch.defaultType?.create();\n\n  //             if (node) {\n  //               tr.insert(cursorPos, node);\n  //             }\n  //           }\n\n  //           // try to put the cursor at the start of the node directly after the inserted horizontal rule\n  //           tr.doc.nodesBetween(cursorPos, cursorPos + 1, (node, pos) => {\n  //             if (node.type.name !== \"horizontalRule\") {\n  //               tr.setSelection(TextSelection.create(tr.doc, pos));\n  //             }\n  //           });\n  //         }\n\n  //         return true;\n  //       })\n  //       .scrollIntoView()\n  //       .run();\n  //     return true;\n  //   },\n  //   [\"hr\", \"horizontalrule\"],\n  //   SeparatorIcon,\n  //   \"Used to separate sections with a horizontal line\"\n  // ),\n\n  // Command for creating a table\n  // table: new SlashCommand(\n  //   \"Table\",\n  //   CommandGroup.BASIC_BLOCKS,\n  //   (editor, range) => {\n  //     editor.chain().focus().deleteRange(range).run();\n  //     // TODO: add blockid, pending https://github.com/ueberdosis/tiptap/pull/1469\n  //     editor\n  //       .chain()\n  //       .focus()\n  //       .insertTable({ rows: 1, cols: 2, withHeaderRow: false })\n  //       .scrollIntoView()\n  //       .run();\n  //     return true;\n  //   },\n  //   [\"table\", \"database\"],\n  //   TableIcon,\n  //   \"Used to create a simple table\"\n  // ),\n];\n","import { Extension } from \"@tiptap/core\";\nimport { getBlockInfoFromPos } from \"../Blocks/helpers/getBlockInfoFromPos\";\n\ndeclare module \"@tiptap/core\" {\n  interface Commands<ReturnType> {\n    textAlignment: {\n      setTextAlignment: (\n        textAlignment: \"left\" | \"center\" | \"right\" | \"justify\"\n      ) => ReturnType;\n    };\n  }\n}\n\nexport const TextAlignmentExtension = Extension.create({\n  name: \"textAlignment\",\n\n  addGlobalAttributes() {\n    return [\n      {\n        // Attribute is applied to block content instead of container so that child blocks don't inherit the text\n        // alignment styling.\n        types: [\"paragraph\", \"heading\", \"bulletListItem\", \"numberedListItem\"],\n        attributes: {\n          textAlignment: {\n            default: \"left\",\n            parseHTML: (element) => element.getAttribute(\"data-text-alignment\"),\n            renderHTML: (attributes) =>\n              attributes.textAlignment !== \"left\" && {\n                \"data-text-alignment\": attributes.textAlignment,\n              },\n          },\n        },\n      },\n    ];\n  },\n\n  addCommands() {\n    return {\n      setTextAlignment:\n        (textAlignment) =>\n        ({ state }) => {\n          const positionsBeforeSelectedContent = [];\n\n          const blockInfo = getBlockInfoFromPos(\n            state.doc,\n            state.selection.from\n          );\n          if (blockInfo === undefined) {\n            return false;\n          }\n\n          // Finds all blockContent nodes that the current selection is in.\n          let pos = blockInfo.startPos;\n          while (pos < state.selection.to) {\n            if (\n              state.doc.resolve(pos).node().type.spec.group === \"blockContent\"\n            ) {\n              positionsBeforeSelectedContent.push(pos - 1);\n\n              pos += state.doc.resolve(pos).node().nodeSize - 1;\n            } else {\n              pos += 1;\n            }\n          }\n\n          // Sets text alignment for all blockContent nodes that the current selection is in.\n          for (const pos of positionsBeforeSelectedContent) {\n            state.tr.setNodeAttribute(pos, \"textAlignment\", textAlignment);\n          }\n\n          return true;\n        },\n    };\n  },\n});\n","import { Extension } from \"@tiptap/core\";\nimport { getBlockInfoFromPos } from \"../Blocks/helpers/getBlockInfoFromPos\";\n\ndeclare module \"@tiptap/core\" {\n  interface Commands<ReturnType> {\n    blockTextColor: {\n      setBlockTextColor: (posInBlock: number, color: string) => ReturnType;\n    };\n  }\n}\n\nexport const TextColorExtension = Extension.create({\n  name: \"blockTextColor\",\n\n  addGlobalAttributes() {\n    return [\n      {\n        types: [\"blockContainer\"],\n        attributes: {\n          textColor: {\n            default: \"default\",\n            parseHTML: (element) =>\n              element.hasAttribute(\"data-text-color\")\n                ? element.getAttribute(\"data-text-color\")\n                : \"default\",\n            renderHTML: (attributes) =>\n              attributes.textColor !== \"default\" && {\n                \"data-text-color\": attributes.textColor,\n              },\n          },\n        },\n      },\n    ];\n  },\n\n  addCommands() {\n    return {\n      setBlockTextColor:\n        (posInBlock, color) =>\n        ({ state, view }) => {\n          const blockInfo = getBlockInfoFromPos(state.doc, posInBlock);\n          if (blockInfo === undefined) {\n            return false;\n          }\n\n          state.tr.setNodeAttribute(blockInfo.startPos - 1, \"textColor\", color);\n\n          view.focus();\n\n          return true;\n        },\n    };\n  },\n});\n","import { Mark } from \"@tiptap/core\";\n\ndeclare module \"@tiptap/core\" {\n  interface Commands<ReturnType> {\n    textColor: {\n      setTextColor: (color: string) => ReturnType;\n    };\n  }\n}\n\nexport const TextColorMark = Mark.create({\n  name: \"textColor\",\n\n  addAttributes() {\n    return {\n      color: {\n        default: undefined,\n        parseHTML: (element) => element.getAttribute(\"data-text-color\"),\n        renderHTML: (attributes) => ({\n          \"data-text-color\": attributes.color,\n        }),\n      },\n    };\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: \"span\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          if (element.hasAttribute(\"data-text-color\")) {\n            return { color: element.getAttribute(\"data-text-color\") };\n          }\n\n          return false;\n        },\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\"span\", HTMLAttributes, 0];\n  },\n\n  addCommands() {\n    return {\n      setTextColor:\n        (color) =>\n        ({ commands }) => {\n          if (color !== \"default\") {\n            return commands.setMark(this.name, { color: color });\n          }\n\n          return commands.unsetMark(this.name);\n        },\n    };\n  },\n});\n","import { Extension } from \"@tiptap/core\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\n\n// based on https://github.com/ueberdosis/tiptap/blob/40a9404c94c7fef7900610c195536384781ae101/demos/src/Experiments/TrailingNode/Vue/trailing-node.ts\n\n/**\n * Extension based on:\n * - https://github.com/ueberdosis/tiptap/blob/v1/packages/tiptap-extensions/src/extensions/TrailingNode.js\n * - https://github.com/remirror/remirror/blob/e0f1bec4a1e8073ce8f5500d62193e52321155b9/packages/prosemirror-trailing-node/src/trailing-node-plugin.ts\n */\n\nexport interface TrailingNodeOptions {\n  node: string;\n}\n\n/**\n * Add a trailing node to the document so the user can always click at the bottom of the document and start typing\n */\nexport const TrailingNode = Extension.create<TrailingNodeOptions>({\n  name: \"trailingNode\",\n\n  addProseMirrorPlugins() {\n    const plugin = new PluginKey(this.name);\n    // const disabledNodes = Object.entries(this.editor.schema.nodes)\n    //   .map(([, value]) => value)\n    //   .filter((node) => this.options.notAfter.includes(node.name));\n\n    return [\n      new Plugin({\n        key: plugin,\n        appendTransaction: (_, __, state) => {\n          const { doc, tr, schema } = state;\n          const shouldInsertNodeAtEnd = plugin.getState(state);\n          const endPosition = doc.content.size - 2;\n          const type = schema.nodes[\"blockContainer\"];\n          const contentType = schema.nodes[\"paragraph\"];\n          if (!shouldInsertNodeAtEnd) {\n            return;\n          }\n\n          return tr.insert(\n            endPosition,\n            type.create(undefined, contentType.create())\n          );\n        },\n        state: {\n          init: (_, _state) => {\n            // (maybe fix): use same logic as apply() here\n            // so it works when initializing\n          },\n          apply: (tr, value) => {\n            if (!tr.docChanged) {\n              return value;\n            }\n\n            let lastNode = tr.doc.lastChild;\n\n            if (!lastNode || lastNode.type.name !== \"blockGroup\") {\n              throw new Error(\"Expected blockGroup\");\n            }\n\n            lastNode = lastNode.lastChild;\n\n            if (!lastNode || lastNode.type.name !== \"blockContainer\") {\n              throw new Error(\"Expected blockContainer\");\n            }\n            return lastNode.nodeSize > 4; // empty <block><content/></block> is length 4\n          },\n        },\n      }),\n    ];\n  },\n});\n","import { Extensions, extensions } from \"@tiptap/core\";\n\nimport { BlockNoteEditor } from \"./BlockNoteEditor\";\n\nimport { Bold } from \"@tiptap/extension-bold\";\nimport { Code } from \"@tiptap/extension-code\";\nimport Collaboration from \"@tiptap/extension-collaboration\";\nimport CollaborationCursor from \"@tiptap/extension-collaboration-cursor\";\nimport { Dropcursor } from \"@tiptap/extension-dropcursor\";\nimport { Gapcursor } from \"@tiptap/extension-gapcursor\";\nimport { HardBreak } from \"@tiptap/extension-hard-break\";\nimport { History } from \"@tiptap/extension-history\";\nimport { Italic } from \"@tiptap/extension-italic\";\nimport { Link } from \"@tiptap/extension-link\";\nimport { Strike } from \"@tiptap/extension-strike\";\nimport { Text } from \"@tiptap/extension-text\";\nimport { Underline } from \"@tiptap/extension-underline\";\nimport * as Y from \"yjs\";\nimport styles from \"./editor.module.css\";\nimport { BackgroundColorExtension } from \"./extensions/BackgroundColor/BackgroundColorExtension\";\nimport { BackgroundColorMark } from \"./extensions/BackgroundColor/BackgroundColorMark\";\nimport { blocks } from \"./extensions/Blocks\";\nimport blockStyles from \"./extensions/Blocks/nodes/Block.module.css\";\nimport { BlockSideMenuFactory } from \"./extensions/DraggableBlocks/BlockSideMenuFactoryTypes\";\nimport { DraggableBlocksExtension } from \"./extensions/DraggableBlocks/DraggableBlocksExtension\";\nimport { FormattingToolbarExtension } from \"./extensions/FormattingToolbar/FormattingToolbarExtension\";\nimport { FormattingToolbarFactory } from \"./extensions/FormattingToolbar/FormattingToolbarFactoryTypes\";\nimport HyperlinkMark from \"./extensions/HyperlinkToolbar/HyperlinkMark\";\nimport { HyperlinkToolbarFactory } from \"./extensions/HyperlinkToolbar/HyperlinkToolbarFactoryTypes\";\nimport { Placeholder } from \"./extensions/Placeholder/PlaceholderExtension\";\nimport { BaseSlashMenuItem, SlashMenuExtension } from \"./extensions/SlashMenu\";\nimport { TextAlignmentExtension } from \"./extensions/TextAlignment/TextAlignmentExtension\";\nimport { TextColorExtension } from \"./extensions/TextColor/TextColorExtension\";\nimport { TextColorMark } from \"./extensions/TextColor/TextColorMark\";\nimport { TrailingNode } from \"./extensions/TrailingNode/TrailingNodeExtension\";\nimport UniqueID from \"./extensions/UniqueID/UniqueID\";\nimport { SuggestionsMenuFactory } from \"./shared/plugins/suggestion/SuggestionsMenuFactoryTypes\";\n\nexport type UiFactories = Partial<{\n  formattingToolbarFactory: FormattingToolbarFactory;\n  hyperlinkToolbarFactory: HyperlinkToolbarFactory;\n  slashMenuFactory: SuggestionsMenuFactory<BaseSlashMenuItem>;\n  blockSideMenuFactory: BlockSideMenuFactory;\n}>;\n\n/**\n * Get all the Tiptap extensions BlockNote is configured with by default\n */\nexport const getBlockNoteExtensions = (opts: {\n  editor: BlockNoteEditor;\n  uiFactories: UiFactories;\n  slashCommands: BaseSlashMenuItem[];\n  collaboration?: {\n    fragment: Y.XmlFragment;\n    user: {\n      name: string;\n      color: string;\n    };\n    provider: any;\n    renderCursor?: (user: any) => HTMLElement;\n  };\n}) => {\n  const ret: Extensions = [\n    extensions.ClipboardTextSerializer,\n    extensions.Commands,\n    extensions.Editable,\n    extensions.FocusEvents,\n    extensions.Tabindex,\n\n    // DevTools,\n    Gapcursor,\n\n    // DropCursor,\n    Placeholder.configure({\n      emptyNodeClass: blockStyles.isEmpty,\n      hasAnchorClass: blockStyles.hasAnchor,\n      isFilterClass: blockStyles.isFilter,\n      includeChildren: true,\n      showOnlyCurrent: false,\n    }),\n    UniqueID.configure({\n      types: [\"blockContainer\"],\n    }),\n    HardBreak,\n    // Comments,\n\n    // basics:\n    Text,\n\n    // marks:\n    Bold,\n    Code,\n    Italic,\n    Strike,\n    Underline,\n    TextColorMark,\n    TextColorExtension,\n    BackgroundColorMark,\n    BackgroundColorExtension,\n    TextAlignmentExtension,\n\n    // custom blocks:\n    ...blocks,\n\n    Dropcursor.configure({ width: 5, color: \"#ddeeff\" }),\n    // This needs to be at the bottom of this list, because Key events (such as enter, when selecting a /command),\n    // should be handled before Enter handlers in other components like splitListItem\n    TrailingNode,\n  ];\n\n  if (opts.collaboration) {\n    ret.push(\n      Collaboration.configure({\n        fragment: opts.collaboration.fragment,\n      })\n    );\n    const defaultRender = (user: { color: string; name: string }) => {\n      const cursor = document.createElement(\"span\");\n\n      cursor.classList.add(styles[\"collaboration-cursor__caret\"]);\n      cursor.setAttribute(\"style\", `border-color: ${user.color}`);\n\n      const label = document.createElement(\"span\");\n\n      label.classList.add(styles[\"collaboration-cursor__label\"]);\n      label.setAttribute(\"style\", `background-color: ${user.color}`);\n      label.insertBefore(document.createTextNode(user.name), null);\n\n      const nonbreakingSpace1 = document.createTextNode(\"\\u2060\");\n      const nonbreakingSpace2 = document.createTextNode(\"\\u2060\");\n      cursor.insertBefore(nonbreakingSpace1, null);\n      cursor.insertBefore(label, null);\n      cursor.insertBefore(nonbreakingSpace2, null);\n      return cursor;\n    };\n    ret.push(\n      CollaborationCursor.configure({\n        user: opts.collaboration.user,\n        render: opts.collaboration.renderCursor || defaultRender,\n        provider: opts.collaboration.provider,\n      })\n    );\n  } else {\n    // disable history extension when collaboration is enabled as Yjs takes care of undo / redo\n    ret.push(History);\n  }\n\n  if (opts.uiFactories.blockSideMenuFactory) {\n    ret.push(\n      DraggableBlocksExtension.configure({\n        editor: opts.editor,\n        blockSideMenuFactory: opts.uiFactories.blockSideMenuFactory,\n      })\n    );\n  }\n\n  if (opts.uiFactories.formattingToolbarFactory) {\n    ret.push(\n      FormattingToolbarExtension.configure({\n        editor: opts.editor,\n        formattingToolbarFactory: opts.uiFactories.formattingToolbarFactory,\n      })\n    );\n  }\n\n  if (opts.uiFactories.hyperlinkToolbarFactory) {\n    ret.push(\n      HyperlinkMark.configure({\n        hyperlinkToolbarFactory: opts.uiFactories.hyperlinkToolbarFactory,\n      })\n    );\n  } else {\n    ret.push(Link);\n  }\n\n  if (opts.uiFactories.slashMenuFactory) {\n    ret.push(\n      SlashMenuExtension.configure({\n        editor: opts.editor,\n        commands: opts.slashCommands,\n        slashMenuFactory: opts.uiFactories.slashMenuFactory,\n      })\n    );\n  }\n\n  return ret;\n};\n","import { Editor, EditorOptions } from \"@tiptap/core\";\nimport { Node } from \"prosemirror-model\";\n// import \"./blocknote.css\";\nimport { Editor as TiptapEditor } from \"@tiptap/core/dist/packages/core/src/Editor\";\nimport * as Y from \"yjs\";\nimport {\n  insertBlocks,\n  removeBlocks,\n  replaceBlocks,\n  updateBlock,\n} from \"./api/blockManipulation/blockManipulation\";\nimport {\n  blocksToHTML,\n  blocksToMarkdown,\n  HTMLToBlocks,\n  markdownToBlocks,\n} from \"./api/formatConversions/formatConversions\";\nimport { nodeToBlock } from \"./api/nodeConversions/nodeConversions\";\nimport { getNodeById } from \"./api/util/nodeUtil\";\nimport { getBlockNoteExtensions, UiFactories } from \"./BlockNoteExtensions\";\nimport styles from \"./editor.module.css\";\nimport {\n  Block,\n  BlockIdentifier,\n  PartialBlock,\n} from \"./extensions/Blocks/api/blockTypes\";\nimport { TextCursorPosition } from \"./extensions/Blocks/api/cursorPositionTypes\";\nimport {\n  ColorStyle,\n  Styles,\n  ToggledStyle,\n} from \"./extensions/Blocks/api/inlineContentTypes\";\nimport { Selection } from \"./extensions/Blocks/api/selectionTypes\";\nimport { getBlockInfoFromPos } from \"./extensions/Blocks/helpers/getBlockInfoFromPos\";\nimport {\n  BaseSlashMenuItem,\n  defaultSlashMenuItems,\n} from \"./extensions/SlashMenu\";\n\nexport type BlockNoteEditorOptions = {\n  // TODO: Figure out if enableBlockNoteExtensions is needed and document them.\n  enableBlockNoteExtensions: boolean;\n\n  /**\n   * UI element factories for creating a custom UI, including custom positioning\n   * & rendering.\n   */\n  uiFactories: UiFactories;\n  /**\n   * TODO: why is this called slashCommands and not slashMenuItems?\n   *\n   * @default defaultSlashMenuItems from `./extensions/SlashMenu`\n   */\n  slashCommands: BaseSlashMenuItem[];\n\n  /**\n   * The HTML element that should be used as the parent element for the editor.\n   *\n   * @default: undefined, the editor is not attached to the DOM\n   */\n  parentElement: HTMLElement;\n  /**\n   * An object containing attributes that should be added to the editor's HTML element.\n   *\n   * @example { class: \"my-editor-class\" }\n   */\n  editorDOMAttributes: Record<string, string>;\n  /**\n   *  A callback function that runs when the editor is ready to be used.\n   */\n  onEditorReady: (editor: BlockNoteEditor) => void;\n  /**\n   * A callback function that runs whenever the editor's contents change.\n   */\n  onEditorContentChange: (editor: BlockNoteEditor) => void;\n  /**\n   * A callback function that runs whenever the text cursor position changes.\n   */\n  onTextCursorPositionChange: (editor: BlockNoteEditor) => void;\n  /**\n   * Locks the editor from being editable by the user if set to `false`.\n   */\n  editable: boolean;\n  /**\n   * The content that should be in the editor when it's created, represented as an array of partial block objects.\n   */\n  initialContent: PartialBlock[];\n  /**\n   * Use default BlockNote font and reset the styles of <p> <li> <h1> elements etc., that are used in BlockNote.\n   *\n   * @default true\n   */\n  defaultStyles: boolean;\n  /**\n   * Whether to use the light or dark theme.\n   *\n   * @default \"light\"\n   */\n  theme: \"light\" | \"dark\";\n\n  /**\n   * When enabled, allows for collaboration between multiple users.\n   */\n  collaboration: {\n    /**\n     * The Yjs XML fragment that's used for collaboration.\n     */\n    fragment: Y.XmlFragment;\n    /**\n     * The user info for the current user that's shown to other collaborators.\n     */\n    user: {\n      name: string;\n      color: string;\n    };\n    /**\n     * A Yjs provider (used for awareness / cursor information)\n     */\n    provider: any;\n    /**\n     * Optional function to customize how cursors of users are rendered\n     */\n    renderCursor?: (user: any) => HTMLElement;\n  };\n\n  // tiptap options, undocumented\n  _tiptapOptions: any;\n};\n\nconst blockNoteTipTapOptions = {\n  enableInputRules: true,\n  enablePasteRules: true,\n  enableCoreExtensions: false,\n};\n\nexport class BlockNoteEditor {\n  public readonly _tiptapEditor: TiptapEditor & { contentComponent: any };\n  private blockCache = new WeakMap<Node, Block>();\n\n  public get domElement() {\n    return this._tiptapEditor.view.dom as HTMLDivElement;\n  }\n\n  public focus() {\n    this._tiptapEditor.view.focus();\n  }\n\n  constructor(private readonly options: Partial<BlockNoteEditorOptions> = {}) {\n    // apply defaults\n    options = {\n      defaultStyles: true,\n      ...options,\n    };\n\n    const extensions = getBlockNoteExtensions({\n      editor: this,\n      uiFactories: options.uiFactories || {},\n      slashCommands: options.slashCommands || defaultSlashMenuItems,\n      collaboration: options.collaboration,\n    });\n\n    const tiptapOptions: EditorOptions = {\n      // TODO: This approach to setting initial content is \"cleaner\" but requires the PM editor schema, which is only\n      //  created after initializing the TipTap editor. Not sure it's feasible.\n      // content:\n      //   options.initialContent &&\n      //   options.initialContent.map((block) =>\n      //     blockToNode(block, this._tiptapEditor.schema).toJSON()\n      //   ),\n      ...blockNoteTipTapOptions,\n      ...options._tiptapOptions,\n      onCreate: () => {\n        options.onEditorReady?.(this);\n        options.initialContent &&\n          this.replaceBlocks(this.topLevelBlocks, options.initialContent);\n      },\n      onUpdate: () => {\n        options.onEditorContentChange?.(this);\n      },\n      onSelectionUpdate: () => {\n        options.onTextCursorPositionChange?.(this);\n      },\n      editable: options.editable === undefined ? true : options.editable,\n      extensions:\n        options.enableBlockNoteExtensions === false\n          ? options._tiptapOptions?.extensions\n          : [...(options._tiptapOptions?.extensions || []), ...extensions],\n      editorProps: {\n        attributes: {\n          \"data-theme\": options.theme || \"light\",\n          ...(options.editorDOMAttributes || {}),\n          class: [\n            styles.bnEditor,\n            styles.bnRoot,\n            options.defaultStyles ? styles.defaultStyles : \"\",\n            options.editorDOMAttributes?.class || \"\",\n          ].join(\" \"),\n        },\n      },\n    };\n\n    if (options.parentElement) {\n      tiptapOptions.element = options.parentElement;\n    }\n\n    this._tiptapEditor = new Editor(tiptapOptions) as Editor & {\n      contentComponent: any;\n    };\n  }\n\n  /**\n   * Gets a snapshot of all top-level (non-nested) blocks in the editor.\n   * @returns A snapshot of all top-level (non-nested) blocks in the editor.\n   */\n  public get topLevelBlocks(): Block[] {\n    const blocks: Block[] = [];\n\n    this._tiptapEditor.state.doc.firstChild!.descendants((node) => {\n      blocks.push(nodeToBlock(node, this.blockCache));\n\n      return false;\n    });\n\n    return blocks;\n  }\n\n  /**\n   * Gets a snapshot of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block that should be retrieved.\n   * @returns The block that matches the identifier, or `undefined` if no matching block was found.\n   */\n  public getBlock(blockIdentifier: BlockIdentifier): Block | undefined {\n    const id =\n      typeof blockIdentifier === \"string\"\n        ? blockIdentifier\n        : blockIdentifier.id;\n    let newBlock: Block | undefined = undefined;\n\n    this._tiptapEditor.state.doc.firstChild!.descendants((node) => {\n      if (typeof newBlock !== \"undefined\") {\n        return false;\n      }\n\n      if (node.type.name !== \"blockContainer\" || node.attrs.id !== id) {\n        return true;\n      }\n\n      newBlock = nodeToBlock(node, this.blockCache);\n\n      return false;\n    });\n\n    return newBlock;\n  }\n\n  /**\n   * Traverses all blocks in the editor depth-first, and executes a callback for each.\n   * @param callback The callback to execute for each block. Returning `false` stops the traversal.\n   * @param reverse Whether the blocks should be traversed in reverse order.\n   */\n  public forEachBlock(\n    callback: (block: Block) => boolean,\n    reverse: boolean = false\n  ): void {\n    const blocks = this.topLevelBlocks.slice();\n\n    if (reverse) {\n      blocks.reverse();\n    }\n\n    function traverseBlockArray(blockArray: Block[]): boolean {\n      for (const block of blockArray) {\n        if (!callback(block)) {\n          return false;\n        }\n\n        const children = reverse\n          ? block.children.slice().reverse()\n          : block.children;\n\n        if (!traverseBlockArray(children)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    traverseBlockArray(blocks);\n  }\n\n  /**\n   * Gets a snapshot of the current text cursor position.\n   * @returns A snapshot of the current text cursor position.\n   */\n  public getTextCursorPosition(): TextCursorPosition {\n    const { node, depth, startPos, endPos } = getBlockInfoFromPos(\n      this._tiptapEditor.state.doc,\n      this._tiptapEditor.state.selection.from\n    )!;\n\n    // Index of the current blockContainer node relative to its parent blockGroup.\n    const nodeIndex = this._tiptapEditor.state.doc\n      .resolve(endPos)\n      .index(depth - 1);\n    // Number of the parent blockGroup's child blockContainer nodes.\n    const numNodes = this._tiptapEditor.state.doc\n      .resolve(endPos + 1)\n      .node().childCount;\n\n    // Gets previous blockContainer node at the same nesting level, if the current node isn't the first child.\n    let prevNode: Node | undefined = undefined;\n    if (nodeIndex > 0) {\n      prevNode = this._tiptapEditor.state.doc.resolve(startPos - 2).node();\n    }\n\n    // Gets next blockContainer node at the same nesting level, if the current node isn't the last child.\n    let nextNode: Node | undefined = undefined;\n    if (nodeIndex < numNodes - 1) {\n      nextNode = this._tiptapEditor.state.doc.resolve(endPos + 2).node();\n    }\n\n    return {\n      block: nodeToBlock(node, this.blockCache),\n      prevBlock:\n        prevNode === undefined\n          ? undefined\n          : nodeToBlock(prevNode, this.blockCache),\n      nextBlock:\n        nextNode === undefined\n          ? undefined\n          : nodeToBlock(nextNode, this.blockCache),\n    };\n  }\n\n  /**\n   * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could\n   * not be found.\n   * @param targetBlock The identifier of an existing block that the text cursor should be moved to.\n   * @param placement Whether the text cursor should be placed at the start or end of the block.\n   */\n  public setTextCursorPosition(\n    targetBlock: BlockIdentifier,\n    placement: \"start\" | \"end\" = \"start\"\n  ) {\n    const id = typeof targetBlock === \"string\" ? targetBlock : targetBlock.id;\n\n    const { posBeforeNode } = getNodeById(id, this._tiptapEditor.state.doc);\n    const { startPos, contentNode } = getBlockInfoFromPos(\n      this._tiptapEditor.state.doc,\n      posBeforeNode + 2\n    )!;\n\n    if (placement === \"start\") {\n      this._tiptapEditor.commands.setTextSelection(startPos + 1);\n    } else {\n      this._tiptapEditor.commands.setTextSelection(\n        startPos + contentNode.nodeSize - 1\n      );\n    }\n  }\n\n  /**\n   * Gets a snapshot of the current selection.\n   */\n  public getSelection(): Selection | undefined {\n    if (\n      this._tiptapEditor.state.selection.from ===\n      this._tiptapEditor.state.selection.to\n    ) {\n      return undefined;\n    }\n\n    const blocks: Block[] = [];\n\n    this._tiptapEditor.state.doc.descendants((node, pos) => {\n      if (node.type.spec.group !== \"blockContent\") {\n        return true;\n      }\n\n      if (\n        pos + node.nodeSize < this._tiptapEditor.state.selection.from ||\n        pos > this._tiptapEditor.state.selection.to\n      ) {\n        return true;\n      }\n\n      blocks.push(\n        nodeToBlock(\n          this._tiptapEditor.state.doc.resolve(pos).node(),\n          this.blockCache\n        )\n      );\n\n      return false;\n    });\n\n    return { blocks: blocks };\n  }\n\n  /**\n   * Checks if the editor is currently editable, or if it's locked.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  public get isEditable(): boolean {\n    return this._tiptapEditor.isEditable;\n  }\n\n  /**\n   * Makes the editor editable or locks it, depending on the argument passed.\n   * @param editable True to make the editor editable, or false to lock it.\n   */\n  public set isEditable(editable: boolean) {\n    this._tiptapEditor.setEditable(editable);\n  }\n\n  /**\n   * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an\n   * error if the reference block could not be found.\n   * @param blocksToInsert An array of partial blocks that should be inserted.\n   * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.\n   * @param placement Whether the blocks should be inserted just before, just after, or nested inside the\n   * `referenceBlock`. Inserts the blocks at the start of the existing block's children if \"nested\" is used.\n   */\n  public insertBlocks(\n    blocksToInsert: PartialBlock[],\n    referenceBlock: BlockIdentifier,\n    placement: \"before\" | \"after\" | \"nested\" = \"before\"\n  ): void {\n    insertBlocks(blocksToInsert, referenceBlock, placement, this._tiptapEditor);\n  }\n\n  /**\n   * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be\n   * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could\n   * not be found.\n   * @param blockToUpdate The block that should be updated.\n   * @param update A partial block which defines how the existing block should be changed.\n   */\n  public updateBlock(blockToUpdate: BlockIdentifier, update: PartialBlock) {\n    updateBlock(blockToUpdate, update, this._tiptapEditor);\n  }\n\n  /**\n   * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.\n   * @param blocksToRemove An array of identifiers for existing blocks that should be removed.\n   */\n  public removeBlocks(blocksToRemove: BlockIdentifier[]) {\n    removeBlocks(blocksToRemove, this._tiptapEditor);\n  }\n\n  /**\n   * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or\n   * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in\n   * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.\n   * @param blocksToRemove An array of blocks that should be replaced.\n   * @param blocksToInsert An array of partial blocks to replace the old ones with.\n   */\n  public replaceBlocks(\n    blocksToRemove: BlockIdentifier[],\n    blocksToInsert: PartialBlock[]\n  ) {\n    replaceBlocks(blocksToRemove, blocksToInsert, this._tiptapEditor);\n  }\n\n  /**\n   * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.\n   */\n  public getActiveStyles() {\n    const styles: Styles = {};\n    const marks = this._tiptapEditor.state.selection.$to.marks();\n\n    const toggleStyles = new Set<ToggledStyle>([\n      \"bold\",\n      \"italic\",\n      \"underline\",\n      \"strike\",\n      \"code\",\n    ]);\n    const colorStyles = new Set<ColorStyle>([\"textColor\", \"backgroundColor\"]);\n\n    for (const mark of marks) {\n      if (toggleStyles.has(mark.type.name as ToggledStyle)) {\n        styles[mark.type.name as ToggledStyle] = true;\n      } else if (colorStyles.has(mark.type.name as ColorStyle)) {\n        styles[mark.type.name as ColorStyle] = mark.attrs.color;\n      }\n    }\n\n    return styles;\n  }\n\n  /**\n   * Adds styles to the currently selected content.\n   * @param styles The styles to add.\n   */\n  public addStyles(styles: Styles) {\n    const toggleStyles = new Set<ToggledStyle>([\n      \"bold\",\n      \"italic\",\n      \"underline\",\n      \"strike\",\n      \"code\",\n    ]);\n    const colorStyles = new Set<ColorStyle>([\"textColor\", \"backgroundColor\"]);\n\n    for (const [style, value] of Object.entries(styles)) {\n      if (toggleStyles.has(style as ToggledStyle)) {\n        this._tiptapEditor.commands.setMark(style);\n      } else if (colorStyles.has(style as ColorStyle)) {\n        this._tiptapEditor.commands.setMark(style, { color: value });\n      }\n    }\n  }\n\n  /**\n   * Removes styles from the currently selected content.\n   * @param styles The styles to remove.\n   */\n  public removeStyles(styles: Styles) {\n    for (const style of Object.keys(styles)) {\n      this._tiptapEditor.commands.unsetMark(style);\n    }\n  }\n\n  /**\n   * Toggles styles on the currently selected content.\n   * @param styles The styles to toggle.\n   */\n  public toggleStyles(styles: Styles) {\n    const toggleStyles = new Set<ToggledStyle>([\n      \"bold\",\n      \"italic\",\n      \"underline\",\n      \"strike\",\n      \"code\",\n    ]);\n    const colorStyles = new Set<ColorStyle>([\"textColor\", \"backgroundColor\"]);\n\n    for (const [style, value] of Object.entries(styles)) {\n      if (toggleStyles.has(style as ToggledStyle)) {\n        this._tiptapEditor.commands.toggleMark(style);\n      } else if (colorStyles.has(style as ColorStyle)) {\n        this._tiptapEditor.commands.toggleMark(style, { color: value });\n      }\n    }\n  }\n\n  /**\n   * Gets the currently selected text.\n   */\n  public getSelectedText() {\n    return this._tiptapEditor.state.doc.textBetween(\n      this._tiptapEditor.state.selection.from,\n      this._tiptapEditor.state.selection.to\n    );\n  }\n\n  /**\n   * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.\n   */\n  public getSelectedLinkUrl() {\n    return this._tiptapEditor.getAttributes(\"link\").href as string | undefined;\n  }\n\n  /**\n   * Creates a new link to replace the selected content.\n   * @param url The link URL.\n   * @param text The text to display the link with.\n   */\n  public createLink(url: string, text?: string) {\n    if (url === \"\") {\n      return;\n    }\n\n    let { from, to } = this._tiptapEditor.state.selection;\n\n    if (!text) {\n      text = this._tiptapEditor.state.doc.textBetween(from, to);\n    }\n\n    const mark = this._tiptapEditor.schema.mark(\"link\", { href: url });\n\n    this._tiptapEditor.view.dispatch(\n      this._tiptapEditor.view.state.tr\n        .insertText(text, from, to)\n        .addMark(from, from + text.length, mark)\n    );\n  }\n\n  /**\n   * Checks if the block containing the text cursor can be nested.\n   */\n  public canNestBlock() {\n    const { startPos, depth } = getBlockInfoFromPos(\n      this._tiptapEditor.state.doc,\n      this._tiptapEditor.state.selection.from\n    )!;\n\n    return this._tiptapEditor.state.doc.resolve(startPos).index(depth - 1) > 0;\n  }\n\n  /**\n   * Nests the block containing the text cursor into the block above it.\n   */\n  public nestBlock() {\n    this._tiptapEditor.commands.sinkListItem(\"blockContainer\");\n  }\n\n  /**\n   * Checks if the block containing the text cursor is nested.\n   */\n  public canUnnestBlock() {\n    const { depth } = getBlockInfoFromPos(\n      this._tiptapEditor.state.doc,\n      this._tiptapEditor.state.selection.from\n    )!;\n\n    return depth > 2;\n  }\n\n  /**\n   * Lifts the block containing the text cursor out of its parent.\n   */\n  public unnestBlock() {\n    this._tiptapEditor.commands.liftListItem(\"blockContainer\");\n  }\n\n  /**\n   * Serializes blocks into an HTML string. To better conform to HTML standards, children of blocks which aren't list\n   * items are un-nested in the output HTML.\n   * @param blocks An array of blocks that should be serialized into HTML.\n   * @returns The blocks, serialized as an HTML string.\n   */\n  public async blocksToHTML(blocks: Block[]): Promise<string> {\n    return blocksToHTML(blocks, this._tiptapEditor.schema);\n  }\n\n  /**\n   * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and\n   * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote\n   * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.\n   * @param html The HTML string to parse blocks from.\n   * @returns The blocks parsed from the HTML string.\n   */\n  public async HTMLToBlocks(html: string): Promise<Block[]> {\n    return HTMLToBlocks(html, this._tiptapEditor.schema);\n  }\n\n  /**\n   * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of\n   * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.\n   * @param blocks An array of blocks that should be serialized into Markdown.\n   * @returns The blocks, serialized as a Markdown string.\n   */\n  public async blocksToMarkdown(blocks: Block[]): Promise<string> {\n    return blocksToMarkdown(blocks, this._tiptapEditor.schema);\n  }\n\n  /**\n   * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on\n   * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it\n   * as text.\n   * @param markdown The Markdown string to parse blocks from.\n   * @returns The blocks parsed from the Markdown string.\n   */\n  public async markdownToBlocks(markdown: string): Promise<Block[]> {\n    return markdownToBlocks(markdown, this._tiptapEditor.schema);\n  }\n\n  /**\n   * Updates the user info for the current user that's shown to other collaborators.\n   */\n  public updateCollaborationUserInfo(user: { name: string; color: string }) {\n    if (!this.options.collaboration) {\n      throw new Error(\n        \"Cannot update collaboration user info when collaboration is disabled.\"\n      );\n    }\n    this._tiptapEditor.commands.updateUser(user);\n  }\n}\n"],"names":["globalProps","blockProps","getBlockInfoFromPos","doc","posInBlock","$pos","maxDepth","node","depth","id","contentNode","contentType","numChildBlocks","startPos","endPos","removeDuplicates","array","by","seen","item","key","findDuplicates","items","filtered","el","index","UniqueID","Extension","v4","element","attributes","extension","view","state","tr","types","attributeName","generateID","findChildren","pos","dragSourceElement","transformPasted","Plugin","PluginKey","transactions","oldState","newState","docChanges","transaction","filterTransactions","_a","_b","transform","combineTransactionSteps","mapping","getChangedRanges","newRange","newNodes","findChildrenInRange","newIds","duplicatedNewIds","deleted","handleDragstart","event","slice","removeId","fragment","list","nodeWithoutId","Fragment","Slice","UnreachableCaseError","val","toggleStyles","colorStyles","styledTextToNode","styledText","schema","marks","style","value","linkToNodes","link","linkMark","styledTextArrayToNodes","content","nodes","inlineContentToNodes","blockContent","blockToNode","block","type","children","child","groupNode","contentNodeToInlineContent","currentLink","styles","mark","nodeToBlock","blockCache","cachedBlock","blockInfo","props","attr","i","getNodeById","targetNode","posBeforeNode","insertBlocks","blocksToInsert","referenceBlock","placement","editor","nodesToInsert","blockSpec","insertionPos","blockGroupNode","updateBlock","blockToUpdate","update","removeBlocks","blocksToRemove","idsOfBlocksToRemove","removedSize","oldDocSize","newDocSize","notFoundIds","replaceBlocks","removeUnderlines","removeUnderlinesHelper","tree","numChildElements","numElementsAdded","simplifyBlocks","options","listItemBlockTypes","simplifyBlocksHelper","activeList","blockContainer","blockGroup","isListItemBlock","listItemBlockType","numElementsRemoved","fromDom","listItemElement","blocksToHTML","blocks","htmlParentElement","serializer","DOMSerializer","htmlNode","unified","rehypeParse","rehypeStringify","HTMLToBlocks","html","parentNode","DOMParser","blocksToMarkdown","rehypeRemark","remarkGfm","remarkStringify","markdownToBlocks","markdown","htmlString","remarkParse","remarkRehype","BackgroundColorExtension","color","BackgroundColorMark","Mark","HTMLAttributes","commands","PLUGIN_KEY","nodeAttributes","PreviousBlockTypePlugin","timeout","_editorView","_prevState","prev","currentTransactionOriginalOldBlockAttrs","oldNodes","oldNodesById","oldNode","oldContentNode","newContentNode","newAttrs","oldAttrs","pluginState","decorations","prevAttrs","decorationAttrs","nodeAttr","decoration","Decoration","DecorationSet","BlockAttributes","BlockContainer","Node","attrs","HTMLAttr","mergeAttributes","dispatch","newBlock","childNodes","posBetweenBlocks","nextNodeIsBlock","prevNodeIsBlock","nextBlockInfo","childBlocksStart","childBlocksEnd","childBlocksRange","prevBlockEndPos","prevBlockInfo","TextSelection","keepType","originalBlockContent","newBlockContent","newBlockInsertionPos","newBlockContentPos","selectionAtBlockStart","isParagraph","selectionEmpty","blockAtDocStart","blockEmpty","blockIndented","chain","BlockGroup","ParagraphBlockContent","HeadingBlockContent","level","InputRule","range","handleEnter","BulletListItemBlockContent","parent","NumberedListIndexingPlugin","_transactions","_oldState","modified","newIndex","isFirstBlockInDoc","prevBlockContentNode","prevBlockIndex","NumberedListItemBlockContent","findBlock","findParentNode","getDefaultPluginState","SuggestionPluginView","pluginKey","selectItemCallback","suggestionsMenuFactory","__publicField","prevState","next","started","stopped","changed","decorationNode","createSuggestionPlugin","defaultTriggerCharacter","deactivate","_c","_d","menuIsActive","triggerCharacter","queryStartPos","keyboardHoveredItemIndex","active","decorationId","blockNode","SlashMenuPluginKey","SlashMenuExtension","query","cmd","MultipleNodeSelection","Selection","$anchor","$head","_pos","from","to","selection","fromResult","toResult","serializeForClipboard","pv","dragImageElement","getDraggableBlockFromCoords","coords","blockPositionFromCoords","docView","desc","blockPositionsFromSelection","beforeFirstBlockPos","afterLastBlockPos","selectionStartInBlockContent","selectionEndInBlockContent","minDepth","startFirstBlockPos","endLastBlockPos","setDragImage","parentClone","getElementIndex","parentElement","targetElement","firstSelectedBlockIndex","lastSelectedBlockIndex","unsetDragImage","inheritedClasses","className","dragStart","e","editorBoundingBox","draggedBlockInSelection","multipleBlocksSelected","NodeSelection","dom","text","BlockMenuView","tiptapEditor","blockMenuFactory","horizontalPosAnchoredAtRoot","evt","_event","blockContentBoundingBox","createDraggableBlocksPlugin","DraggableBlocksExtension","FormattingToolbarView","formattingToolbarFactory","shouldShow","empty","isEmptyTextBlock","isTextSelection","composing","isSame","ranges","isNodeSelection","posToDOMRect","createFormattingToolbarPlugin","FormattingToolbarExtension","HyperlinkToolbarView","hyperlinkToolbarFactory","hoveredHyperlinkElement","posInHoveredHyperlinkMark","resolvedPosInHoveredHyperlinkMark","marksAtPos","getMarkRange","prevHyperlinkMark","url","createHyperlinkToolbarPlugin","Hyperlink","Link","Placeholder","menuState","anchor","hasAnchor","isEmpty","classes","SuggestionItem","name","match","BaseSlashMenuItem","execute","aliases","alias","insertOrUpdateBlock","currentBlock","defaultSlashMenuItems","TextAlignmentExtension","textAlignment","positionsBeforeSelectedContent","TextColorExtension","TextColorMark","TrailingNode","plugin","_","__","shouldInsertNodeAtEnd","endPosition","_state","lastNode","getBlockNoteExtensions","opts","ret","extensions","Gapcursor","blockStyles","HardBreak","Text","Bold","Code","Italic","Strike","Underline","Dropcursor","Collaboration","defaultRender","user","cursor","label","nonbreakingSpace1","nonbreakingSpace2","CollaborationCursor","History","HyperlinkMark","blockNoteTipTapOptions","BlockNoteEditor","tiptapOptions","Editor","blockIdentifier","callback","reverse","traverseBlockArray","blockArray","nodeIndex","numNodes","prevNode","nextNode","targetBlock","editable"],"mappings":"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"}